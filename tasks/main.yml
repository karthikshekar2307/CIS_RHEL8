# - name: "1.1.1.1 | Ensure cramfs kernel module is not available (Automated)"
#   block:

#     - name: Check if cramfs kernel module is available
#       command: modinfo cramfs
#       register: cramfs_module
#       ignore_errors: true
#       changed_when: false

#     - name: Unload cramfs kernel module if loaded
#       ansible.builtin.shell: "modprobe -r cramfs"
#       when: "'cramfs_module' in vars and cramfs_module.rc == 0"
#       ignore_errors: true

#     - name: Blacklist cramfs module
#       ansible.builtin.lineinfile:
#         path: /etc/modprobe.d/cramfs.conf
#         line: "blacklist cramfs"
#         create: yes
#         mode: '0644'
#         owner: root
#         group: root
#       when: "'cramfs_module' in vars and cramfs_module.rc == 0"

#     - name: Prevent cramfs module from loading
#       ansible.builtin.lineinfile:
#         path: /etc/modprobe.d/cramfs.conf
#         line: "install cramfs /bin/false"
#         create: yes
#         mode: '0644'
#         owner: root
#         group: root
#       when: "'cramfs_module' in vars and cramfs_module.rc == 0"

#   rescue:
#     - name: Fallback info if cramfs_module was not defined
#       debug:
#         msg: "cramfs module not available or 'modinfo' command failed â€” skipping tasks"

# - name: "1.1.1.2 | Ensure freevxfs kernel module is not available (Automated)"
#   block:

#     - name: Check if freevxfs kernel module is available
#       command: modinfo freevxfs
#       register: freevxfs_module
#       ignore_errors: true
#       changed_when: false

#     - name: Unload freevxfs kernel module if loaded
#       ansible.builtin.shell: "modprobe -r freevxfs"
#       when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"
#       ignore_errors: true

#     - name: Blacklist freevxfs module
#       ansible.builtin.lineinfile:
#         path: /etc/modprobe.d/freevxfs.conf
#         line: "blacklist freevxfs"
#         create: yes
#         mode: '0644'
#         owner: root
#         group: root
#       when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

#     - name: Prevent freevxfs module from loading
#       ansible.builtin.lineinfile:
#         path: /etc/modprobe.d/freevxfs.conf
#         line: "install freevxfs /bin/false"
#         create: yes
#         mode: '0644'
#         owner: root
#         group: root
#       when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

#   rescue:
#     - name: Fallback info if freevxfs_module was not defined
#       debug:
#         msg: "freevxfs module not available or 'modinfo' command failed â€” skipping tasks"

# # 1.1.1.3 Ensure hfs kernel module is not available
# - name: Check if hfs kernel module is available
#   command: modinfo hfs
#   register: hfs_module
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.3



# - name: Unload hfs kernel module if loaded
#   command: modprobe -r hfs
#   when: hfs_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.3

# - name: Blacklist hfs module
#   lineinfile:
#     path: /etc/modprobe.d/hfs.conf
#     line: "blacklist hfs"
#     create: yes
#   when: hfs_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.3

# - name: Prevent hfs module from loading
#   lineinfile:
#     path: /etc/modprobe.d/hfs.conf
#     line: "install hfs /bin/false"
#     create: yes
#   when: hfs_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.3

# # 1.1.1.4 Ensure hfsplus kernel module is not available
# - name: Check if hfsplus kernel module is available
#   command: modinfo hfsplus
#   register: hfsplus_module
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.4

# - name: Unload hfsplus kernel module if loaded
#   command: modprobe -r hfsplus
#   when: hfsplus_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.4

# - name: Blacklist hfsplus module
#   lineinfile:
#     path: /etc/modprobe.d/hfsplus.conf
#     line: "blacklist hfsplus"
#     create: yes
#   when: hfsplus_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.4

# - name: Prevent hfsplus module from loading
#   lineinfile:
#     path: /etc/modprobe.d/hfsplus.conf
#     line: "install hfsplus /bin/false"
#     create: yes
#   when: hfsplus_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.4

# # 1.1.1.5 Ensure jffs2 kernel module is not available
# - name: Check if jffs2 kernel module is available
#   command: modinfo jffs2
#   register: jffs2_module
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.5

# - name: Unload jffs2 kernel module if loaded
#   command: modprobe -r jffs2
#   when: jffs2_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.5

# - name: Blacklist jffs2 module
#   lineinfile:
#     path: /etc/modprobe.d/jffs2.conf
#     line: "blacklist jffs2"
#     create: yes
#   when: jffs2_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.5

# - name: Prevent jffs2 module from loading
#   lineinfile:
#     path: /etc/modprobe.d/jffs2.conf
#     line: "install jffs2 /bin/false"
#     create: yes
#   when: jffs2_module.rc == 0
#   tags:
#     - level1
#     - server
#     - workstation
#     - cis_1.1.1.5

# # 1.1.1.6 Ensure squashfs kernel module is not available
# - name: Check if squashfs kernel module is available
#   command: modinfo squashfs
#   register: squashfs_module
#   ignore_errors: true
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.6

# - name: Unload squashfs kernel module if loaded
#   command: modprobe -r squashfs
#   when: squashfs_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.6

# - name: Blacklist squashfs module
#   lineinfile:
#     path: /etc/modprobe.d/squashfs.conf
#     line: "blacklist squashfs"
#     create: yes
#   when: squashfs_module.rc == 0
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.6

# - name: Prevent squashfs module from loading
#   lineinfile:
#     path: /etc/modprobe.d/squashfs.conf
#     line: "install squashfs /bin/false"
#     create: yes
#   when: squashfs_module.rc == 0
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.6

# # 1.1.1.7 Ensure udf kernel module is not available
# - name: Check if udf kernel module is available
#   command: modinfo udf
#   register: udf_module
#   ignore_errors: true
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.7

# - name: Unload udf kernel module if loaded
#   command: modprobe -r udf
#   when: udf_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.7

# - name: Blacklist udf module
#   lineinfile:
#     path: /etc/modprobe.d/udf.conf
#     line: "blacklist udf"
#     create: yes
#   when: udf_module.rc == 0
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.7

# - name: Prevent udf module from loading
#   lineinfile:
#     path: /etc/modprobe.d/udf.conf
#     line: "install udf /bin/false"
#     create: yes
#   when: udf_module.rc == 0
#   tags:
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.7

# # 1.1.1.8 Ensure usb-storage kernel module is not available
# - name: Check if usb-storage kernel module is available
#   command: modinfo usb-storage
#   register: usb_storage_module
#   ignore_errors: true
#   tags:
#     - level1
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.8

# - name: Unload usb-storage kernel module if loaded
#   command: modprobe -r usb-storage
#   when: usb_storage_module.rc == 0
#   ignore_errors: true
#   tags:
#     - level1
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.8

# - name: Blacklist usb-storage kernel module
#   lineinfile:
#     path: /etc/modprobe.d/usb-storage.conf
#     line: "blacklist usb-storage"
#     create: yes
#   when: usb_storage_module.rc == 0
#   tags:
#     - level1
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.8

# - name: Prevent usb-storage kernel module from loading
#   lineinfile:
#     path: /etc/modprobe.d/usb-storage.conf
#     line: "install usb-storage /bin/false"
#     create: yes
#   when: usb_storage_module.rc == 0
#   tags:
#     - level1
#     - level2
#     - server
#     - workstation
#     - cis_1.1.1.8

# # 1.1.2.1.1 Ensure /tmp is a separate partition using tmpfs
# - name: Ensure systemd tmp.mount is unmasked
#   command: systemctl unmask tmp.mount
#   ignore_errors: true
#   tags:
#     - cis_1.1.2.1.1

# - name: Ensure /tmp mount directory exists
#   file:
#     path: /tmp
#     state: directory
#     mode: '1777'

# - name: Add /tmp entry to /etc/fstab
#   mount:
#     path: /tmp
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
#     state: mounted
#   tags:
#     - cis_1.1.2.1.1

# - name: Ensure /tmp is mounted with nodev option
#   mount:
#     path: /tmp
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
#     state: mounted
#   tags:
#     - cis_1.1.2.1.2

# - name: Ensure /tmp is mounted with nosuid option
#   mount:
#     path: /tmp
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
#     state: mounted
#   tags:
#     - cis_1.1.2.1.3

# - name: Ensure /tmp is mounted with nodev, nosuid, and noexec
#   mount:
#     path: /tmp
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
#     state: mounted
#   tags:
#     - cis_1.1.2.1.4

# - name: Ensure /dev/shm is mounted as a separate tmpfs partition with secure options
#   mount:
#     path: /dev/shm
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
#     state: mounted
#   tags:
#     - cis_1.1.2.2.1

# - name: Ensure nodev is set on /dev/shm
#   mount:
#     path: /dev/shm
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.2.2

# - name: Ensure nosuid is set on /dev/shm
#   mount:
#     path: /dev/shm
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.2.3

# - name: Ensure noexec is set on /dev/shm
#   mount:
#     path: /dev/shm
#     src: tmpfs
#     fstype: tmpfs
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.2.4

# # - name: Mount /home on its own partition
# #   mount:
# #     path: /home
# #     src: "/dev/vg_main/lv_home"
# #     fstype: ext4
# #     opts: defaults,rw,nosuid,nodev,noexec,relatime
# #     state: mounted
# #   tags:
# #     - cis_1.1.2.3.1

# # - name: Ensure /home is mounted with nodev
# #   mount:
# #     path: /home
# #     src: /dev/vg_main/lv_home
# #     fstype: ext4
# #     opts: defaults,rw,nosuid,nodev,noexec,relatime
# #     state: mounted
# #   tags:
# #     - cis_1.1.2.3.2

# # - name: Ensure /home is mounted with nosuid
# #   mount:
# #     path: /home
# #     src: /dev/vg_main/lv_home
# #     fstype: ext4
# #     opts: defaults,rw,nosuid,nodev,noexec,relatime
# #     state: mounted
# #   tags:
# #     - cis_1.1.2.3.3

# # - name: Mount /var as a separate partition
# #   mount:
# #     path: /var
# #     src: /dev/xvdf1
# #     fstype: ext4
# #     opts: defaults,nosuid,nodev,noexec,relatime
# #     state: mounted
# #     dump: 0
# #     passno: 2

# # - name: Ensure nodev option is set on /var
# #   mount:
# #     path: /var
# #     src: /dev/xvdf1
# #     fstype: ext4
# #     opts: defaults,rw,nosuid,nodev,noexec,relatime
# #     state: mounted
# #     dump: 0
# #     passno: 2

# # - name: Ensure mount point exists for /var/tmp
# #   file:
# #     path: /var/tmp
# #     state: directory
# #     mode: '1777'

# # - name: Mount /var/tmp with secure options
# #   mount:
# #     path: /var/tmp
# #     src: /dev/xvdf1           # Replace with your actual device
# #     fstype: ext4
# #     opts: defaults,nodev,nosuid,noexec,relatime
# #     state: mounted
# #     dump: 0
# #     passno: 0

# # - name: Persist mount in /etc/fstab
# #   mount:
# #     path: /var/tmp
# #     src: /dev/xvdf1           # Replace with your actual device
# #     fstype: ext4
# #     opts: defaults,nodev,nosuid,noexec,relatime
# #     state: present
# #     dump: 0
# #     passno: 0

# # - name: Ensure /var/tmp is mounted with nodev option
# #   mount:
# #     path: /var/tmp
# #     src: /dev/xvdf1               # ðŸ” Replace with the correct device
# #     fstype: ext4                  # ðŸ” Adjust if you're using a different filesystem
# #     opts: defaults,nodev,nosuid,noexec,relatime
# #     state: mounted
# #     dump: 0
# #     passno: 0

# # - name: Ensure /var/tmp fstab entry is present with nodev option
# #   mount:
# #     path: /var/tmp
# #     src: /dev/xvdf1               # ðŸ” Replace as needed
# #     fstype: ext4
# #     opts: defaults,nodev,nosuid,noexec,relatime
# #     state: present
# #     dump: 0
# #     passno: 0

# # - name: Remount /var/tmp with noexec option if already mounted
# #   mount:
# #     path: /var/tmp
# #     fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='fstype') | first | default('ext4') }}"
# #     opts: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='options') | first | default([]) 
# #              | union(['noexec']) 
# #              | union(['nodev']) 
# #              | union(['nosuid']) 
# #              | unique | join(',') }}"
# #     state: remounted

# # - name: Ensure /var/tmp entry in /etc/fstab has noexec, nodev, nosuid
# #   lineinfile:
# #     path: /etc/fstab
# #     regexp: '^([^#\s]+\s+/var/tmp\s+[^#\s]+\s+)([^#\s]+)'
# #     line: '\1defaults,nodev,nosuid,noexec,relatime'
# #     backrefs: yes

# # - name: Check if /var/log is on a separate partition
# #   command: findmnt -n /var/log
# #   register: varlog_mount
# #   changed_when: false
# #   failed_when: varlog_mount.rc != 0
# #   ignore_errors: true

# # - name: Fail if /var/log is not a separate partition
# #   fail:
# #     msg: "/var/log is not a separate partition. Please configure it manually and re-run."
# #   when: varlog_mount.rc != 0

# # - name: Extract filesystem type for /var/log
# #   set_fact:
# #     varlog_fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"

# # - name: Extract existing mount options for /var/log
# #   set_fact:
# #     varlog_options: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# # - name: Ensure /var/log is remounted with secure mount options
# #   mount:
# #     path: /var/log
# #     fstype: "{{ varlog_fstype }}"
# #     opts: "{{ varlog_options | union(['noexec', 'nodev', 'nosuid']) | unique | join(',') }}"
# #     state: remounted

# # - name: Ensure /etc/fstab entry for /var/log has secure options
# #   lineinfile:
# #     path: /etc/fstab
# #     regexp: '^([^#\s]+\s+/var/log\s+[^#\s]+\s+)([^#\s]+)'
# #     line: '\1defaults,nodev,nosuid,noexec,relatime'
# #     backrefs: yes

# # - name: Check if /var/log is a separate partition
# #   command: findmnt -n /var/log
# #   register: varlog_partition
# #   changed_when: false
# #   failed_when: varlog_partition.rc != 0
# #   ignore_errors: true

# # - name: Fail if /var/log is not a separate partition
# #   fail:
# #     msg: "/var/log is not a separate partition. Manual intervention is required to create one."
# #   when: varlog_partition.rc != 0

# # - name: Get current fstype and mount options for /var/log
# #   set_fact:
# #     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
# #     varlog_opts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# # - name: Ensure nodev is added to mount options at runtime
# #   mount:
# #     path: /var/log
# #     fstype: "{{ varlog_fstype }}"
# #     opts: "{{ varlog_opts | union(['nodev']) | unique | join(',') }}"
# #     state: remounted

# # - name: Persist nodev in /etc/fstab for /var/log
# #   lineinfile:
# #     path: /etc/fstab
# #     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
# #     line: '\1defaults,nodev,nosuid,noexec,relatime'
# #     backrefs: yes

# # - name: Check if /var/log is a separate partition
# #   command: findmnt -n /var/log
# #   register: varlog_partition_check
# #   changed_when: false
# #   failed_when: varlog_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Fail if /var/log is not a separate partition
# #   fail:
# #     msg: "/var/log is not a separate partition. Manual intervention required to create one as per CIS."
# #   when: varlog_partition_check.rc != 0

# # - name: Get current mount options and fstype for /var/log
# #   set_fact:
# #     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
# #     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# # - name: Ensure nosuid is added to /var/log mount options at runtime
# #   mount:
# #     path: /var/log
# #     fstype: "{{ varlog_fstype }}"
# #     opts: "{{ varlog_mountopts | union(['nosuid']) | union(['nodev', 'noexec', 'relatime']) | unique | join(',') }}"
# #     state: remounted

# # - name: Persist nosuid in /etc/fstab for /var/log
# #   lineinfile:
# #     path: /etc/fstab
# #     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
# #     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
# #     backrefs: yes

# # - name: Check if /var/log is a separate partition
# #   command: findmnt -n /var/log
# #   register: varlog_partition_check
# #   changed_when: false
# #   failed_when: varlog_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Fail if /var/log is not a separate partition
# #   fail:
# #     msg: "/var/log is not a separate partition. Manual intervention required to comply with CIS 1.1.2.6.4"
# #   when: varlog_partition_check.rc != 0

# # - name: Get current mount options and fstype for /var/log
# #   set_fact:
# #     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
# #     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# # - name: Ensure noexec is added to /var/log mount options at runtime
# #   mount:
# #     path: /var/log
# #     fstype: "{{ varlog_fstype }}"
# #     opts: "{{ varlog_mountopts | union(['noexec']) | union(['nosuid', 'nodev', 'relatime']) | unique | join(',') }}"
# #     state: remounted

# # - name: Persist noexec in /etc/fstab for /var/log
# #   lineinfile:
# #     path: /etc/fstab
# #     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
# #     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
# #     backrefs: yes

# # - name: Check if /var/log/audit is a separate partition
# #   command: findmnt -n /var/log/audit
# #   register: audit_partition_check
# #   changed_when: false
# #   failed_when: audit_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Fail if /var/log/audit is not a separate partition
# #   fail:
# #     msg: "/var/log/audit is not a separate partition. Please create a dedicated partition as per CIS 1.1.2.7.1"
# #   when: audit_partition_check.rc != 0

# # - name: Check if /var/log/audit is a separate partition
# #   command: findmnt -n /var/log/audit
# #   register: audit_partition_check
# #   changed_when: false
# #   failed_when: audit_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Check if nodev option is set on /var/log/audit
# #   command: findmnt -nk /var/log/audit | grep -w nodev
# #   register: nodev_option_check
# #   changed_when: false
# #   failed_when: nodev_option_check.rc != 0
# #   when: audit_partition_check.rc == 0
# #   ignore_errors: true

# # - name: Warn if nodev is not set on /var/log/audit
# #   debug:
# #     msg: "The /var/log/audit partition exists but 'nodev' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.2."
# #   when: audit_partition_check.rc == 0 and nodev_option_check.rc != 0

# # - name: Check if /var/log/audit is a separate partition
# #   command: findmnt -n /var/log/audit
# #   register: audit_partition_check
# #   changed_when: false
# #   failed_when: audit_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Check if nosuid option is set on /var/log/audit
# #   command: findmnt -nk /var/log/audit | grep -w nosuid
# #   register: nosuid_option_check
# #   changed_when: false
# #   failed_when: nosuid_option_check.rc != 0
# #   when: audit_partition_check.rc == 0
# #   ignore_errors: true

# # - name: Warn if nosuid is not set on /var/log/audit
# #   debug:
# #     msg: "The /var/log/audit partition exists but 'nosuid' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.3."
# #   when: audit_partition_check.rc == 0 and nosuid_option_check.rc != 0

# # - name: Check if /var/log/audit is a separate partition
# #   command: findmnt -n /var/log/audit
# #   register: audit_partition_check
# #   changed_when: false
# #   failed_when: audit_partition_check.rc != 0
# #   ignore_errors: true

# # - name: Check if noexec option is set on /var/log/audit
# #   command: findmnt -nk /var/log/audit | grep -w noexec
# #   register: noexec_option_check
# #   changed_when: false
# #   failed_when: noexec_option_check.rc != 0
# #   when: audit_partition_check.rc == 0
# #   ignore_errors: true

# # - name: Warn if noexec is not set on /var/log/audit
# #   debug:
# #     msg: "The /var/log/audit partition exists but 'noexec' is not set. Please update /etc/fstab and remount to comply with CIS 1.1.2.7.4."
# #   when: audit_partition_check.rc == 0 and noexec_option_check.rc != 0

# - name: Check for GPG key URL configuration in repos
#   shell: grep -r gpgkey /etc/yum.repos.d/* /etc/dnf/dnf.conf || true
#   register: gpgkey_urls
#   changed_when: false

# - name: Print configured GPG key URLs
#   debug:
#     msg: "{{ gpgkey_urls.stdout_lines }}"

# - name: List installed GPG keys from rpm
#   shell: |
#     for RPM_PACKAGE in $(rpm -q gpg-pubkey); do
#       echo "RPM: ${RPM_PACKAGE}"
#       echo "Packager: $(rpm -q --queryformat '%{PACKAGER}' ${RPM_PACKAGE})"
#       echo "Summary: $(rpm -q --queryformat '%{SUMMARY}' ${RPM_PACKAGE})"
#       echo "Key ID: $(rpm -q --queryformat '%{VERSION}' ${RPM_PACKAGE})"
#       echo "Created: $(date -d "1970-01-01 +$((0x$(rpm -q --queryformat '%{RELEASE}' ${RPM_PACKAGE})) ) sec" +%Y-%m-%d)"
#       echo ""
#     done
#   register: installed_gpg_keys
#   changed_when: false

# - name: Display installed GPG keys
#   debug:
#     msg: "{{ installed_gpg_keys.stdout_lines }}"

# - name: Ensure gpgcheck is set to 1 in /etc/dnf/dnf.conf
#   ansible.builtin.lineinfile:
#     path: /etc/dnf/dnf.conf
#     regexp: '^gpgcheck\s*='
#     line: 'gpgcheck=1'
#     insertafter: '^\[main\]'
#     backup: yes
#   #notify: Reload DNF

# - name: Ensure gpgcheck is set to 1 in all yum repo files
#   ansible.builtin.find:
#     paths: /etc/yum.repos.d/
#     patterns: "*.repo"
#   register: repo_files

# - name: Fix gpgcheck entries in all repo files
#   ansible.builtin.replace:
#     path: "{{ item.path }}"
#     regexp: '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)\b'
#     replace: 'gpgcheck=1'
#     backup: yes
#   loop: "{{ repo_files.files }}"
#   when: repo_files.matched > 0
#   #notify: Reload DNF

# - name: Audit gpgcheck in dnf.conf
#   command: grep '^gpgcheck=' /etc/dnf/dnf.conf
#   register: dnf_gpgcheck
#   changed_when: false

# - name: Ensure gpgcheck is set to 1 in global dnf.conf
#   ini_file:
#     path: /etc/dnf/dnf.conf
#     section: main
#     option: gpgcheck
#     value: '1'
#     state: present
#     backup: yes

# - name: Ensure gpgcheck is set to 1 in all yum repo files
#   find:
#     paths: /etc/yum.repos.d/
#     patterns: '*.repo'
#   register: yum_repo_files

# - name: Set gpgcheck=1 in each repo file
#   lineinfile:
#     path: "{{ item.path }}"
#     regexp: '^\s*gpgcheck\s*=\s*'
#     line: 'gpgcheck=1'
#     state: present
#     backup: yes
#   loop: "{{ yum_repo_files.files }}"
#   when: yum_repo_files.matched > 0

# - name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
#   ini_file:
#     path: /etc/dnf/dnf.conf
#     section: main
#     option: repo_gpgcheck
#     value: '1'
#     state: present
#     backup: yes

# - name: Ensure repo_gpgcheck is set to 1 in all yum repo files
#   find:
#     paths: /etc/yum.repos.d/
#     patterns: '*.repo'
#   register: yum_repo_files_for_repo_gpgcheck

# - name: Set repo_gpgcheck=1 in each repo file
#   lineinfile:
#     path: "{{ item.path }}"
#     regexp: '^\s*repo_gpgcheck\s*=\s*'
#     line: 'repo_gpgcheck=1'
#     state: present
#     backup: yes
#   loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
#   when: yum_repo_files_for_repo_gpgcheck.matched > 0

# - name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
#   ini_file:
#     path: /etc/dnf/dnf.conf
#     section: main
#     option: repo_gpgcheck
#     value: '1'
#     state: present
#     backup: yes

# - name: Ensure repo_gpgcheck is set to 1 in all yum repo files
#   find:
#     paths: /etc/yum.repos.d/
#     patterns: '*.repo'
#   register: yum_repo_files_for_repo_gpgcheck

# - name: Set repo_gpgcheck=1 in each repo file
#   lineinfile:
#     path: "{{ item.path }}"
#     regexp: '^\s*repo_gpgcheck\s*=\s*'
#     line: 'repo_gpgcheck=1'
#     state: present
#     backup: yes
#   loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
#   when: yum_repo_files_for_repo_gpgcheck.matched > 0

# - name: "CIS 1.2.4 | Audit: Ensure package manager repositories are configured"
#   ansible.builtin.shell: "dnf repolist --quiet | grep -E '^[a-zA-Z0-9_-]+\\s+.+\\s+[0-9]+'"
#   register: repo_check
#   changed_when: false
#   failed_when: repo_check.stdout_lines | length == 0
#   tags:
#     - level1
#     - section1.2.4

# - name: "CIS 1.2.5 | Audit: Check for available package updates"
#   ansible.builtin.shell: "dnf check-update || true"
#   register: dnf_check
#   changed_when: false
#   failed_when: false
#   tags:
#     - level1
#     - section1.2.5

# - name: CIS 1.2.5 | Ensure updates, patches, and additional security software are installed
#   shell: |
#     dnf update -y && dnf needs-restarting -r || true
#   register: cis_125_updates
#   changed_when: cis_125_updates.rc != 0 or ('Nothing to do' not in cis_125_updates.stdout | default(''))
#   failed_when: false
#   tags:
#     - level1-server
#     - level1-workstation
#     - patching

# - name: "CIS 1.4.1 | Ensure ASLR is enabled (kernel.randomize_va_space = 2)"
#   ansible.posix.sysctl:
#     name: kernel.randomize_va_space
#     value: '2'
#     sysctl_set: true
#     state: present
#     reload: yes
#   tags:
#     - level1-server
#     - level1-workstation
#     - sysctl
#     - aslr

# - name: "CIS 1.4.2 | Ensure ptrace_scope is restricted (kernel.yama.ptrace_scope = 1)"
#   ansible.posix.sysctl:
#     name: kernel.yama.ptrace_scope
#     value: "1"
#     sysctl_set: true
#     state: present
#     reload: yes
#   tags:
#     - level1-server
#     - level1-workstation
#     - ptrace
#     - sysctl

# - name: "CIS 1.4.3 | Ensure core dump backtraces are disabled (ProcessSizeMax=0)"
#   ansible.builtin.lineinfile:
#     path: /etc/systemd/coredump.conf
#     regexp: '^#?ProcessSizeMax='
#     line: 'ProcessSizeMax=0'
#     create: yes
#     backup: yes
#   #notify: Reload systemd-coredump
#   tags:
#     - level1-server
#     - level1-workstation
#     - coredump

# - name: "CIS 1.4.4 | Ensure core dump storage is disabled (Storage=none)"
#   ansible.builtin.lineinfile:
#     path: /etc/systemd/coredump.conf
#     regexp: '^#?Storage='
#     line: 'Storage=none'
#     create: yes
#     backup: yes
#   #notify: Reload systemd-coredump

# - name: CIS 1.5.1.1 | Ensure SELinux is installed using bash fallback
#   ansible.builtin.shell: |
#     if ! rpm -q libselinux >/dev/null 2>&1; then
#       dnf install -y libselinux --nogpgcheck
#     fi
#   register: selinux_install_result
#   changed_when: selinux_install_result.rc == 0
#   failed_when: selinux_install_result.rc != 0

# - name: CIS 1.5.1.2 | Ensure SELinux is not disabled in bootloader configuration
#   ansible.builtin.command: grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"
#   register: selinux_boot_fix
#   changed_when: selinux_boot_fix.rc == 0
#   failed_when: selinux_boot_fix.rc != 0

# - name: CIS 1.5.1.3 | Ensure SELINUXTYPE is configured as targeted or mls
#   ansible.builtin.lineinfile:
#     path: /etc/selinux/config
#     regexp: '^SELINUXTYPE='
#     line: 'SELINUXTYPE=targeted'
#     state: present
#     backup: yes

# - name: CIS 1.5.1.4 | Ensure SELinux mode is not disabled in config file
#   ansible.builtin.lineinfile:
#     path: /etc/selinux/config
#     regexp: '^SELINUX='
#     line: 'SELINUX=enforcing'
#     backup: yes

# - name: CIS 1.5.1.4 | Set SELinux running mode to enforcing
#   ansible.builtin.command: setenforce 1
#   when: ansible_selinux.status == "permissive"
#   changed_when: true
#   failed_when: false

# - name: CIS 1.5.1.5 | Ensure SELinux mode is set to enforcing in config file
#   ansible.builtin.lineinfile:
#     path: /etc/selinux/config
#     regexp: '^SELINUX='
#     line: 'SELINUX=enforcing'
#     backup: yes

# - name: CIS 1.5.1.5 | Ensure SELinux runtime mode is enforcing
#   ansible.builtin.command: setenforce 1
#   when: ansible_selinux.status != "enforcing"
#   changed_when: true
#   failed_when: false

# - name: CIS 1.5.1.6 | Audit for unconfined services
#   ansible.builtin.command: ps -eZ
#   register: unconfined_processes

# - name: CIS 1.5.1.6 | Fail if unconfined services are found
#   ansible.builtin.fail:
#     msg: "Unconfined services exist: {{ unconfined_list }}"
#   when: unconfined_list | length > 0
#   vars:
#     unconfined_list: "{{ unconfined_processes.stdout_lines | select('search', 'unconfined_service_t') | list }}"

# - name: CIS 1.5.1.7 | Check if mcstrans is installed
#   ansible.builtin.package_facts:

# - name: CIS 1.5.1.7 | Remove mcstrans package if installed
#   ansible.builtin.package:
#     name: mcstrans
#     state: absent
#   when: "'mcstrans' in ansible_facts.packages"

# - name: CIS 1.5.1.8 | Check if setroubleshoot is installed
#   ansible.builtin.package_facts:

# - name: CIS 1.5.1.8 | Remove setroubleshoot if installed
#   ansible.builtin.package:
#     name: setroubleshoot
#     state: absent
#   when: "'setroubleshoot' in ansible_facts.packages"

# - name: CIS 1.6.1 | Check if system-wide crypto policy is LEGACY
#   ansible.builtin.command: grep -Pi '^\h*LEGACY\b' /etc/crypto-policies/config
#   register: legacy_crypto_policy_check
#   changed_when: false
#   failed_when: false

# - name: CIS 1.6.1 | Remediate if system-wide crypto policy is LEGACY
#   ansible.builtin.command: update-crypto-policies --set DEFAULT
#   when: legacy_crypto_policy_check.rc == 0

# - name: CIS 1.6.1 | Ensure crypto policy changes are applied
#   ansible.builtin.command: update-crypto-policies
#   when: legacy_crypto_policy_check.rc == 0

# - name: CIS 1.6.2 | Create NO-SHA1 policy module to disable SHA1
#   ansible.builtin.copy:
#     dest: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
#     content: |
#       # This is a subpolicy dropping the SHA1 hash and signature support
#       hash = -SHA1
#       sign = -*-SHA1
#       sha1_in_certs = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.6.2 | Apply crypto policy with NO-SHA1 module
#   ansible.builtin.command: update-crypto-policies --set DEFAULT:NO-SHA1
#   register: crypto_policy_sha1
#   changed_when: "'DEFAULT:NO-SHA1' not in crypto_policy_sha1.stdout"

# - name: CIS 1.6.2 | Reboot system to activate crypto policy (manual or controlled)
#   ansible.builtin.debug:
#     msg: "System needs to be rebooted to fully apply updated crypto policy."
#   when: crypto_policy_sha1 is changed

# - name: CIS 1.6.2 | Create NO-SHA1 subpolicy module
#   copy:
#     dest: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
#     content: |
#       # This is a subpolicy dropping the SHA1 hash and signature support
#       hash = -SHA1
#       sign = -*-SHA1
#       sha1_in_certs = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.6.3 | Create NO-SSHCBC subpolicy module
#   copy:
#     dest: /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod
#     content: |
#       # This is a subpolicy to disable all CBC mode ciphers
#       # for the SSH protocol (libssh and OpenSSH)
#       cipher@SSH = -*-CBC
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.6.4 | Create NO-WEAKMAC subpolicy module
#   copy:
#     dest: /etc/crypto-policies/policies/modules/NO-WEAKMAC.pmod
#     content: |
#       # This is a subpolicy to disable weak macs
#       mac = -*-64
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.6.x | Apply crypto policy with all required subpolicies
#   command: update-crypto-policies --set DEFAULT:NO-SHA1:NO-SSHCBC:NO-WEAKMAC
#   register: apply_crypto_policy
#   changed_when: "'DEFAULT:NO-SHA1:NO-SSHCBC:NO-WEAKMAC' not in apply_crypto_policy.stdout"

# - name: CIS 1.6.x | Notify reboot is required to fully apply crypto policies
#   debug:
#     msg: "System reboot is required to fully apply updated crypto policy (NO-SHA1, NO-SSHCBC, NO-WEAKMAC)."
#   when: apply_crypto_policy is changed

# - name: CIS 1.7.2 | Set local login warning banner in /etc/issue
#   copy:
#     dest: /etc/issue
#     content: |
#       Authorized users only. All activity may be monitored and reported.
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.7.3 | Set remote login warning banner in /etc/issue.net
#   copy:
#     dest: /etc/issue.net
#     content: |
#       Authorized users only. All activity may be monitored and reported.
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 1.7.4 | Ensure /etc/motd has correct permissions and ownership
#   file:
#     path: /etc/motd
#     owner: root
#     group: root
#     mode: '0644'
#     state: file

# - name: CIS 1.7.5 | Ensure /etc/issue has correct permissions and ownership
#   file:
#     path: /etc/issue
#     owner: root
#     group: root
#     mode: '0644'
#     state: file

# - name: CIS 1.7.6 | Ensure /etc/issue.net has correct permissions and ownership
#   file:
#     path: /etc/issue.net
#     owner: root
#     group: root
#     mode: '0644'
#     state: file

# # - name: CIS 1.8.1 | Ensure GNOME Display Manager (GDM) is removed
# #   package:
# #     name: gdm
# #     state: absent

# - name: CIS 1.8.1 | Ensure GNOME Display Manager (GDM) is removed
#   ansible.builtin.shell: dnf remove -y gdm

# - name: "Check if GDM is installed"
#   ansible.builtin.command: rpm -q gdm
#   register: gdm_installed
#   changed_when: false
#   failed_when: false

# - name: "CIS 1.8.2 | Ensure GDM login banner is configured"
#   block:
#     - name: "Ensure /etc/dconf/profile/gdm exists"
#       ansible.builtin.copy:
#         dest: /etc/dconf/profile/gdm
#         content: |
#           user-db:user
#           system-db:gdm
#           file-db:/usr/share/gdm/greeter-dconf-defaults
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Ensure dconf directory exists"
#       ansible.builtin.file:
#         path: /etc/dconf/db/gdm.d/
#         state: directory
#         owner: root
#         group: root
#         mode: '0755'

#     - name: "Configure banner message"
#       ansible.builtin.copy:
#         dest: /etc/dconf/db/gdm.d/01-banner-message
#         content: |
#           [org/gnome/login-screen]
#           banner-message-enable=true
#           banner-message-text='Authorized users only. All activity may be monitored and reported.'
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Run dconf update"
#       ansible.builtin.command: dconf update

#   when: gdm_installed.rc == 0

# - name: "Check if GDM is installed"
#   ansible.builtin.command: rpm -q gdm
#   register: gdm_installed
#   changed_when: false
#   failed_when: false

# - name: "CIS 1.8.3 | Ensure GDM disable-user-list option is enabled"
#   block:

#     - name: "Ensure dconf profile exists for gdm"
#       ansible.builtin.copy:
#         dest: /etc/dconf/profile/gdm
#         content: |
#           user-db:user
#           system-db:gdm
#           file-db:/usr/share/gdm/greeter-dconf-defaults
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Ensure dconf db directory exists"
#       ansible.builtin.file:
#         path: /etc/dconf/db/gdm.d/
#         state: directory
#         owner: root
#         group: root
#         mode: '0755'

#     - name: "Configure disable-user-list in gdm"
#       ansible.builtin.copy:
#         dest: /etc/dconf/db/gdm.d/00-login-screen
#         content: |
#           [org/gnome/login-screen]
#           # Do not show the user list
#           disable-user-list=true
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Update dconf database"
#       ansible.builtin.command: dconf update

#   when: gdm_installed.rc == 0

# - name: "Check if GDM is installed"
#   ansible.builtin.command: rpm -q gdm
#   register: gdm_installed
#   changed_when: false
#   failed_when: false

# - name: "CIS 1.8.4 | Ensure GDM screen locks when the user is idle"
#   block:

#     - name: "Ensure /etc/dconf/profile/gdm exists"
#       ansible.builtin.copy:
#         dest: /etc/dconf/profile/gdm
#         content: |
#           user-db:user
#           system-db:gdm
#           file-db:/usr/share/gdm/greeter-dconf-defaults
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Ensure /etc/dconf/db/gdm.d exists"
#       ansible.builtin.file:
#         path: /etc/dconf/db/gdm.d
#         state: directory
#         mode: '0755'
#         owner: root
#         group: root

#     - name: "Set idle-delay and lock-delay in GDM keyfile"
#       ansible.builtin.copy:
#         dest: /etc/dconf/db/gdm.d/00-screensaver
#         content: |
#           [org/gnome/desktop/session]
#           # Number of seconds of inactivity before the screen goes blank
#           idle-delay=uint32 900

#           [org/gnome/desktop/screensaver]
#           # Number of seconds after the screen is blank before locking the screen
#           lock-delay=uint32 5
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Update dconf database"
#       ansible.builtin.command: dconf update

#   when: gdm_installed.rc == 0

# - name: "Check if GDM is installed"
#   ansible.builtin.command: rpm -q gdm
#   register: gdm_installed
#   changed_when: false
#   failed_when: false

# - name: "Get dconf db directory containing idle-delay"
#   ansible.builtin.shell: |
#     grep -Psril '^\h*idle-delay\h*=\h*uint32\h+\d+\b' /etc/dconf/db/*/ | head -n 1
#   register: idle_delay_keyfile
#   changed_when: false
#   failed_when: false
#   when: gdm_installed.rc == 0

# - name: "Extract dconf db directory"
#   ansible.builtin.set_fact:
#     dconf_lock_dir: "{{ idle_delay_keyfile.stdout | regex_replace('/[^/]+$', '') }}"
#   when: idle_delay_keyfile is defined and (idle_delay_keyfile.stdout | default('')) != ""


# - name: "Ensure locks directory exists"
#   ansible.builtin.file:
#     path: "{{ dconf_lock_dir }}/locks"
#     state: directory
#     owner: root
#     group: root
#     mode: '0755'
#   when: dconf_lock_dir is defined

# - name: "Create lock file to prevent override of idle-delay and lock-delay"
#   ansible.builtin.copy:
#     dest: "{{ dconf_lock_dir }}/locks/00-screensaver"
#     content: |
#       # Lock desktop screensaver settings
#       /org/gnome/desktop/session/idle-delay
#       /org/gnome/desktop/screensaver/lock-delay
#     owner: root
#     group: root
#     mode: '0644'
#   when: dconf_lock_dir is defined

# - name: "Run dconf update"
#   ansible.builtin.command: dconf update
#   when: dconf_lock_dir is defined

# - name: "CIS 1.8.6 | Check if GDM is installed"
#   command: rpm -q gdm
#   register: gdm_installed
#   failed_when: false
#   changed_when: false

# - name: "CIS 1.8.6 | Ensure GDM automatic mounting of removable media is disabled"
#   shell: |
#     GDM_PROFILE="local"
#     GDM_DB_DIR="/etc/dconf/db/${GDM_PROFILE}.d"
#     GDM_PROFILE_FILE="/etc/dconf/profile/user"

#     mkdir -p "${GDM_DB_DIR}"

#     if [ ! -f "${GDM_PROFILE_FILE}" ]; then
#       echo -e "user-db:user\nsystem-db:${GDM_PROFILE}" > "${GDM_PROFILE_FILE}"
#     fi

#     KEY_FILE="${GDM_DB_DIR}/00-media-automount"

#     {
#       echo "[org/gnome/desktop/media-handling]"
#       echo "automount=false"
#       echo "automount-open=false"
#     } > "$KEY_FILE"

#     dconf update
#   when: gdm_installed.rc == 0
#   args:
#     executable: /bin/bash
#   tags:
#     - level1-server
#     - level2-workstation
#     - cis_1.8.6

# - name: "CIS 1.8.7 | Lock GDM automount and automount-open settings"
#   shell: |
#     # Set dconf profile name (default is 'local', adjust if needed)
#     GDM_PROFILE="local"
#     DB_DIR="/etc/dconf/db/${GDM_PROFILE}.d"
#     LOCKS_DIR="${DB_DIR}/locks"
#     LOCK_FILE="${LOCKS_DIR}/00-media-automount"

#     # Ensure locks directory exists
#     mkdir -p "${LOCKS_DIR}"

#     # Create or update the lock file
#     grep -q "/org/gnome/desktop/media-handling/automount" "${LOCK_FILE}" 2>/dev/null || echo "/org/gnome/desktop/media-handling/automount" >> "${LOCK_FILE}"
#     grep -q "/org/gnome/desktop/media-handling/automount-open" "${LOCK_FILE}" 2>/dev/null || echo "/org/gnome/desktop/media-handling/automount-open" >> "${LOCK_FILE}"

#     # Update dconf database
#     dconf update
#   args:
#     executable: /bin/bash
#   when: gdm_installed.rc == 0
#   tags:
#     - level1-server
#     - level2-workstation
#     - cis_1.8.7

# - name: "CIS 1.8.8 | Ensure GDM autorun-never is enabled"
#   shell: |
#     GP_NAME="local"
#     KFILE="/etc/dconf/db/${GP_NAME}.d/00-media-autorun"
#     GPDIR="/etc/dconf/db/${GP_NAME}.d"
#     GPFILE="/etc/dconf/profile/user"

#     # Create profile file if not present
#     if ! grep -Pq "^\s*system-db:${GP_NAME}\b" $GPFILE 2>/dev/null; then
#       echo -e "\nuser-db:user" >> $GPFILE
#       echo "system-db:${GP_NAME}" >> $GPFILE
#     fi

#     # Ensure dconf directory exists
#     mkdir -p "$GPDIR"

#     # Create or update autorun-never entry
#     if grep -Pqs '^\s*autorun-never\s*=\s*true\b' "$KFILE"; then
#       echo "autorun-never already set to true"
#     elif grep -Psq '^\s*autorun-never' "$KFILE"; then
#       sed -ri 's/(^\s*autorun-never\s*=\s*)(\S+)(\s*.*)$/\1true\3/' "$KFILE"
#     else
#       grep -Psq '^\s*\[org/gnome/desktop/media-handling\]' "$KFILE" || echo '[org/gnome/desktop/media-handling]' >> "$KFILE"
#       sed -ri '/^\s*\[org\/gnome\/desktop\/media-handling\]/a autorun-never=true' "$KFILE"
#     fi

#     # Update dconf database
#     dconf update
#   args:
#     executable: /bin/bash
#   when: gdm_installed.rc == 0
#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_1.8.8

# - name: "CIS 1.8.9 | Ensure GDM autorun-never is not overridden"
#   shell: |
#     GP_NAME="local"
#     GP_DIR="/etc/dconf/db/${GP_NAME}.d"
#     LOCKS_DIR="${GP_DIR}/locks"
#     LOCK_FILE="${LOCKS_DIR}/00-media-autorun"

#     # Identify actual directory if setting already exists
#     if grep -Prilsq -- '^\s*autorun-never\s*=' /etc/dconf/db/*.d; then
#       GP_NAME="$(grep -Prils -- '^\s*autorun-never\s*=' /etc/dconf/db/*.d | head -n1 | awk -F'/' '{split($(NF-1), a, "."); print a[1]}')"
#       GP_DIR="/etc/dconf/db/${GP_NAME}.d"
#       LOCKS_DIR="${GP_DIR}/locks"
#       LOCK_FILE="${LOCKS_DIR}/00-media-autorun"
#     fi

#     # Create the locks directory if not exists
#     mkdir -p "$LOCKS_DIR"

#     # Ensure lock line exists
#     grep -Fxq "/org/gnome/desktop/media-handling/autorun-never" "$LOCK_FILE" 2>/dev/null || {
#       echo "# Lock desktop media-handling autorun-never setting" >> "$LOCK_FILE"
#       echo "/org/gnome/desktop/media-handling/autorun-never" >> "$LOCK_FILE"
#     }

#     # Update dconf
#     dconf update
#   args:
#     executable: /bin/bash
#   when: gdm_installed.rc == 0
#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_1.8.9

# - name: "CIS 1.8.10 | Ensure XDMCP is not enabled"
#   block:
#     - name: "Check if GDM is installed"
#       command: rpm -q gdm
#       register: gdm_installed
#       failed_when: false
#       changed_when: false

#     - name: "Ensure XDMCP Enable=true is not set in /etc/gdm/custom.conf"
#       lineinfile:
#         path: /etc/gdm/custom.conf
#         regexp: '^\s*Enable\s*=\s*true'
#         state: absent
#         backup: yes
#       when: gdm_installed.rc == 0
#       notify: reload gdm
#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_1.8.10

# - name: "CIS 2.1.1 | Ensure time synchronization is in use"
#   block:

#     - name: "Check if chrony is installed"
#       command: rpm -q chrony
#       register: chrony_installed
#       failed_when: false
#       changed_when: false

#     - name: "Install chrony if not present"
#       ansible.builtin.yum:
#         name: chrony
#         state: present
#       when: chrony_installed.rc != 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.1.1

# - name: "CIS 2.1.2 | Ensure chrony is configured"
#   block:

#     - name: "Check if chrony.conf has server or pool entries"
#       command: grep -Prs -- '^\s*(server|pool)\s+[^#\n\r]+' /etc/chrony.conf
#       register: chrony_configured
#       failed_when: false
#       changed_when: false

#     - name: "Configure chrony with remote NTP servers if missing"
#       blockinfile:
#         path: /etc/chrony.conf
#         marker: "# {mark} ANSIBLE MANAGED BLOCK: CIS 2.1.2 NTP Configuration"
#         block: |
#           server time1.google.com iburst
#           server time2.google.com iburst
#           server time3.google.com iburst
#       when: chrony_configured.rc != 0

#     - name: "Ensure chronyd service is enabled and running"
#       service:
#         name: chronyd
#         state: started
#         enabled: true

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.1.2

# - name: "CIS 2.1.3 | Ensure chrony is not run as the root user"
#   block:

#     - name: "Ensure chronyd OPTIONS is set to run as 'chrony' user"
#       lineinfile:
#         path: /etc/sysconfig/chronyd
#         regexp: '^OPTIONS='
#         line: 'OPTIONS="-u chrony"'
#         create: yes
#         backup: yes

#     - name: "Reload or restart chronyd service"
#       systemd:
#         name: chronyd
#         state: restarted
#         daemon_reload: yes

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.1.3

# - name: "CIS 2.2.1 | Ensure autofs services are not in use"
#   block:

#     - name: "Check if autofs is installed"
#       command: rpm -q autofs
#       register: autofs_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove autofs package if installed"
#       yum:
#         name: autofs
#         state: absent
#       when: autofs_installed.rc == 0

#     - name: "Stop autofs service if it exists"
#       systemd:
#         name: autofs
#         state: stopped
#         enabled: false
#         masked: true
#       when: autofs_installed.rc == 0

#   tags:
#     - level1-server
#     - level2-workstation
#     - cis_2.2.1

# - name: "CIS 2.2.2 | Ensure avahi daemon services are not in use"
#   block:

#     - name: "Check if avahi is installed"
#       command: rpm -q avahi
#       register: avahi_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove avahi package if installed"
#       yum:
#         name: avahi
#         state: absent
#       when: avahi_installed.rc == 0

#     - name: "Stop and mask avahi-daemon services if avahi is present"
#       block:
#         - name: "Stop avahi-daemon.service and socket"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - avahi-daemon.service
#             - avahi-daemon.socket

#         - name: "Mask avahi-daemon.service and socket"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - avahi-daemon.service
#             - avahi-daemon.socket
#       when: avahi_installed.rc == 0

#   tags:
#     - level1-server
#     - level2-workstation
#     - cis_2.2.2

# - name: "CIS 2.2.3 | Ensure DHCP server services are not in use"
#   block:

#     - name: "Check if dhcp-server is installed"
#       command: rpm -q dhcp-server
#       register: dhcp_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove dhcp-server package if installed"
#       yum:
#         name: dhcp-server
#         state: absent
#       when: dhcp_installed.rc == 0

#     - name: "Stop and mask dhcpd and dhcpd6 services if dhcp-server is installed"
#       block:
#         - name: "Stop dhcpd and dhcpd6 services"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - dhcpd.service
#             - dhcpd6.service

#         - name: "Mask dhcpd and dhcpd6 services"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - dhcpd.service
#             - dhcpd6.service
#       when: dhcp_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.3

# - name: "CIS 2.2.4 | Ensure DNS server services are not in use"
#   block:

#     - name: "Check if bind package is installed"
#       command: rpm -q bind
#       register: bind_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove bind package if installed"
#       yum:
#         name: bind
#         state: absent
#       when: bind_installed.rc == 0

#     - name: "Stop and mask named.service if bind is installed and cannot be removed"
#       block:
#         - name: "Stop named.service"
#           systemd:
#             name: named.service
#             state: stopped
#             enabled: false

#         - name: "Mask named.service"
#           systemd:
#             name: named.service
#             masked: true
#       when: bind_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.4

# - name: "CIS 2.2.5 | Ensure dnsmasq services are not in use"
#   block:

#     - name: "Check if dnsmasq package is installed"
#       command: rpm -q dnsmasq
#       register: dnsmasq_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove dnsmasq package if installed"
#       yum:
#         name: dnsmasq
#         state: absent
#       when: dnsmasq_installed.rc == 0

#     - name: "Stop and mask dnsmasq.service if package is installed and cannot be removed"
#       block:
#         - name: "Stop dnsmasq.service"
#           systemd:
#             name: dnsmasq.service
#             state: stopped
#             enabled: false

#         - name: "Mask dnsmasq.service"
#           systemd:
#             name: dnsmasq.service
#             masked: true
#       when: dnsmasq_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.5

# - name: "CIS 2.2.6 | Ensure samba file server services are not in use"
#   block:

#     - name: "Check if samba package is installed"
#       command: rpm -q samba
#       register: samba_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove samba package if installed"
#       yum:
#         name: samba
#         state: absent
#       when: samba_installed.rc == 0

#     - name: "Stop and mask smb.service if samba package is installed and cannot be removed"
#       block:
#         - name: "Stop smb.service"
#           systemd:
#             name: smb.service
#             state: stopped
#             enabled: false

#         - name: "Mask smb.service"
#           systemd:
#             name: smb.service
#             masked: true
#       when: samba_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.6

# - name: "CIS 2.2.7 | Ensure ftp server services are not in use"
#   block:

#     - name: "Check if vsftpd package is installed"
#       command: rpm -q vsftpd
#       register: vsftpd_installed
#       ignore_errors: yes
#       changed_when: false

#     - name: "Remove vsftpd package if installed"
#       yum:
#         name: vsftpd
#         state: absent
#       when: vsftpd_installed.rc == 0

#     - name: "Stop and mask vsftpd.service if vsftpd package is installed and not removed"
#       block:
#         - name: "Stop vsftpd.service"
#           systemd:
#             name: vsftpd.service
#             state: stopped
#             enabled: false

#         - name: "Mask vsftpd.service"
#           systemd:
#             name: vsftpd.service
#             masked: true
#       when: vsftpd_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.7

# - name: "CIS 2.2.8 | Ensure message access server services are not in use"
#   block:

#     - name: "Check if dovecot package is installed"
#       command: rpm -q dovecot
#       register: dovecot_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Check if cyrus-imapd package is installed"
#       command: rpm -q cyrus-imapd
#       register: cyrus_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove dovecot and cyrus-imapd packages if installed"
#       yum:
#         name:
#           - dovecot
#           - cyrus-imapd
#         state: absent
#       when: dovecot_installed.rc == 0 or cyrus_installed.rc == 0

#     - name: "Stop and mask dovecot and cyrus-imapd services if packages are required"
#       block:
#         - name: "Stop dovecot and cyrus-imapd services"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - dovecot.socket
#             - dovecot.service
#             - cyrus-imapd.service
#           ignore_errors: true

#         - name: "Mask dovecot and cyrus-imapd services"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - dovecot.socket
#             - dovecot.service
#             - cyrus-imapd.service
#           ignore_errors: true
#       when: dovecot_installed.rc == 0 or cyrus_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.8

# - name: "CIS 2.2.9 | Ensure NFS services are not in use"
#   block:

#     - name: "Check if nfs-utils package is installed"
#       command: rpm -q nfs-utils
#       register: nfs_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove nfs-utils package if installed"
#       yum:
#         name: nfs-utils
#         state: absent
#       when: nfs_installed.rc == 0

#     - name: "Stop and mask nfs-server service if package is required"
#       block:
#         - name: "Stop nfs-server.service"
#           systemd:
#             name: nfs-server.service
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask nfs-server.service"
#           systemd:
#             name: nfs-server.service
#             masked: true
#           ignore_errors: true
#       when: nfs_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.9

# - name: "CIS 2.2.10 | Ensure NIS server services are not in use"
#   block:

#     - name: "Check if ypserv package is installed"
#       command: rpm -q ypserv
#       register: ypserv_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove ypserv package if installed"
#       yum:
#         name: ypserv
#         state: absent
#       when: ypserv_installed.rc == 0

#     - name: "Stop and mask ypserv.service if package is required"
#       block:
#         - name: "Stop ypserv.service"
#           systemd:
#             name: ypserv.service
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask ypserv.service"
#           systemd:
#             name: ypserv.service
#             masked: true
#           ignore_errors: true
#       when: ypserv_installed.rc == 0

#   tags:
#     - level1-server
#     - level1-workstation
#     - cis_2.2.10

# - name: "CIS 2.2.11 | Ensure print server services (CUPS) are not in use"
#   block:

#     - name: "Check if cups package is installed"
#       command: rpm -q cups
#       register: cups_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove cups package if installed"
#       yum:
#         name: cups
#         state: absent
#       when: cups_installed.rc == 0

#     - name: "Stop and mask cups.socket and cups.service if package is required"
#       block:
#         - name: "Stop cups.socket and cups.service"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - cups.socket
#             - cups.service
#           ignore_errors: true

#         - name: "Mask cups.socket and cups.service"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - cups.socket
#             - cups.service
#           ignore_errors: true
#       when: cups_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.11

# - name: "CIS 2.2.12 | Ensure rpcbind services are not in use"
#   block:

#     - name: "Check if rpcbind package is installed"
#       command: rpm -q rpcbind
#       register: rpcbind_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove rpcbind package if installed"
#       yum:
#         name: rpcbind
#         state: absent
#       when: rpcbind_installed.rc == 0

#     - name: "Stop and mask rpcbind.socket and rpcbind.service if package is required"
#       block:
#         - name: "Stop rpcbind.socket and rpcbind.service"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - rpcbind.socket
#             - rpcbind.service
#           ignore_errors: true

#         - name: "Mask rpcbind.socket and rpcbind.service"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - rpcbind.socket
#             - rpcbind.service
#           ignore_errors: true
#       when: rpcbind_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.12

# - name: "CIS 2.2.13 | Ensure rsync services are not in use"
#   block:

#     - name: "Check if rsync-daemon package is installed"
#       command: rpm -q rsync-daemon
#       register: rsyncd_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove rsync-daemon package if installed"
#       yum:
#         name: rsync-daemon
#         state: absent
#       when: rsyncd_installed.rc == 0

#     - name: "Stop and mask rsyncd.socket and rsyncd.service if package is required"
#       block:
#         - name: "Stop rsyncd.socket and rsyncd.service"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - rsyncd.socket
#             - rsyncd.service
#           ignore_errors: true

#         - name: "Mask rsyncd.socket and rsyncd.service"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - rsyncd.socket
#             - rsyncd.service
#           ignore_errors: true
#       when: rsyncd_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.13

# - name: "CIS 2.2.14 | Ensure SNMP services are not in use"
#   block:

#     - name: "Check if net-snmp package is installed"
#       command: rpm -q net-snmp
#       register: snmp_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove net-snmp package if installed"
#       yum:
#         name: net-snmp
#         state: absent
#       when: snmp_installed.rc == 0

#     - name: "Stop and mask snmpd.service if package is required"
#       block:
#         - name: "Stop snmpd.service"
#           systemd:
#             name: snmpd.service
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask snmpd.service"
#           systemd:
#             name: snmpd.service
#             masked: true
#           ignore_errors: true
#       when: snmp_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.14

# - name: "CIS 2.2.15 | Ensure Telnet server services are not in use"
#   block:

#     - name: "Check if telnet-server package is installed"
#       command: rpm -q telnet-server
#       register: telnet_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove telnet-server package if installed"
#       yum:
#         name: telnet-server
#         state: absent
#       when: telnet_installed.rc == 0

#     - name: "Stop and mask telnet.socket if package is required"
#       block:
#         - name: "Stop telnet.socket"
#           systemd:
#             name: telnet.socket
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask telnet.socket"
#           systemd:
#             name: telnet.socket
#             masked: true
#           ignore_errors: true
#       when: telnet_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.15

# - name: "CIS 2.2.16 | Ensure TFTP server services are not in use"
#   block:

#     - name: "Check if tftp-server package is installed"
#       command: rpm -q tftp-server
#       register: tftp_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove tftp-server package if installed"
#       yum:
#         name: tftp-server
#         state: absent
#       when: tftp_installed.rc == 0

#     - name: "Stop and mask tftp.socket and tftp.service if package is required"
#       block:
#         - name: "Stop tftp.socket and tftp.service"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - tftp.socket
#             - tftp.service
#           ignore_errors: true

#         - name: "Mask tftp.socket and tftp.service"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - tftp.socket
#             - tftp.service
#           ignore_errors: true
#       when: tftp_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.16

# - name: "CIS 2.2.17 | Ensure web proxy server services (Squid) are not in use"
#   block:

#     - name: "Check if squid package is installed"
#       command: rpm -q squid
#       register: squid_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove squid package if installed"
#       yum:
#         name: squid
#         state: absent
#       when: squid_installed.rc == 0

#     - name: "Stop and mask squid.service if package is required for dependency"
#       block:
#         - name: "Stop squid.service"
#           systemd:
#             name: squid.service
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask squid.service"
#           systemd:
#             name: squid.service
#             masked: true
#           ignore_errors: true
#       when: squid_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.17

# - name: "CIS 2.2.18 | Ensure web server services (httpd, nginx) are not in use"
#   block:

#     - name: "Check if httpd package is installed"
#       command: rpm -q httpd
#       register: httpd_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Check if nginx package is installed"
#       command: rpm -q nginx
#       register: nginx_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove httpd and nginx if installed"
#       yum:
#         name:
#           - httpd
#           - nginx
#         state: absent
#       when: httpd_installed.rc == 0 or nginx_installed.rc == 0

#     - name: "Stop and mask httpd.socket, httpd.service, and nginx.service if packages are present for dependency"
#       block:
#         - name: "Stop web server services"
#           systemd:
#             name: "{{ item }}"
#             state: stopped
#             enabled: false
#           loop:
#             - httpd.socket
#             - httpd.service
#             - nginx.service
#           ignore_errors: true

#         - name: "Mask web server services"
#           systemd:
#             name: "{{ item }}"
#             masked: true
#           loop:
#             - httpd.socket
#             - httpd.service
#             - nginx.service
#           ignore_errors: true
#       when: httpd_installed.rc == 0 or nginx_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.18

# - name: "CIS 2.2.19 | Ensure xinetd services are not in use"
#   block:

#     - name: "Check if xinetd package is installed"
#       command: rpm -q xinetd
#       register: xinetd_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove xinetd package if installed"
#       yum:
#         name: xinetd
#         state: absent
#       when: xinetd_installed.rc == 0

#     - name: "Stop and mask xinetd.service if required as a dependency"
#       block:
#         - name: "Stop xinetd.service"
#           systemd:
#             name: xinetd.service
#             state: stopped
#             enabled: false
#           ignore_errors: true

#         - name: "Mask xinetd.service"
#           systemd:
#             name: xinetd.service
#             masked: true
#           ignore_errors: true
#       when: xinetd_installed.rc == 0

#   tags:
#     - level1-server
#     - cis_2.2.19

# - name: "CIS 2.2.20 | Ensure X window server services are not in use"
#   block:

#     - name: "Check if xorg-x11-server-common package is installed"
#       command: rpm -q xorg-x11-server-common
#       register: xorg_installed
#       ignore_errors: true
#       changed_when: false

#     - name: "Remove xorg-x11-server-common package if installed"
#       yum:
#         name: xorg-x11-server-common
#         state: absent
#       when: xorg_installed.rc == 0

#   tags:
#     - level2-server
#     - cis_2.2.20

# - name: Disable GPG check temporarily to install postfix (NOT recommended for prod)
#   shell: |
#     dnf install -y postfix --nogpgcheck
#   args:
#     executable: /bin/bash


# - name: Configure Postfix to listen only on loopback
#   lineinfile:
#     path: /etc/postfix/main.cf
#     line: 'inet_interfaces = loopback-only'
#     regexp: '^inet_interfaces\s*='
#     insertafter: '^#.*RECEIVING MAIL'
#     state: present
#     backup: yes


# - name: Ensure Postfix service is enabled and running
#   service:
#     name: postfix
#     state: started
#     enabled: yes
#   when: ansible_facts.packages.postfix is defined
# - name: Audit listening services and ports (ss -plntu)
#   shell: ss -plntu > /var/log/listening_ports_audit.log
#   args:
#     executable: /bin/bash
#   register: ss_output

# - name: Show listening services for manual review
#   debug:
#     var: ss_output.stdout_lines

# - name: Stop and mask unapproved service if exists
#   systemd:
#     name: "{{ item }}"
#     state: stopped
#     enabled: false
#     masked: true
#   loop:
#     - telnet.socket
#     - telnet.service
#     - cups.service
#     - avahi-daemon.service
#   ignore_errors: true
#   failed_when: false

# - name: Remove unapproved packages (ignore GPG)
#   shell: dnf remove -y {{ item }} --nogpgcheck
#   loop:
#     - telnet
#     - cups
#     - avahi
#   args:
#     executable: /bin/bash
#   ignore_errors: true

# - name: Ensure FTP client is not installed
#   package:
#     name: ftp
#     state: absent
#   ignore_errors: true  # Prevent task failure if repo metadata is broken

# - name: Check if FTP is installed
#   shell: rpm -q ftp
#   register: ftp_check
#   ignore_errors: true

# - name: Report FTP package status
#   debug:
#     msg: "{{ ftp_check.stdout if ftp_check.rc == 0 else 'FTP is not installed' }}"

# - name: Ensure LDAP client is not installed (openldap-clients)
#   package:
#     name: openldap-clients
#     state: absent
#   ignore_errors: true  # Handles missing repos or package gracefully

# - name: Check if openldap-clients is installed
#   shell: rpm -q openldap-clients
#   register: ldap_check
#   ignore_errors: true

# - name: Report LDAP client installation status
#   debug:
#     msg: "{{ ldap_check.stdout if ldap_check.rc == 0 else 'openldap-clients is not installed' }}"

# - name: Remove openldap-clients with --nogpgcheck (RHUI workaround)
#   shell: dnf remove -y openldap-clients --nogpgcheck
#   args:
#     executable: /bin/bash
#   ignore_errors: true

# - name: Ensure NIS client is not installed (ypbind)
#   package:
#     name: ypbind
#     state: absent
#   ignore_errors: true  # Useful in air-gapped or repo-issue environments

# - name: Check if ypbind is installed
#   shell: rpm -q ypbind
#   register: nis_check
#   ignore_errors: true

# - name: Report NIS client installation status
#   debug:
#     msg: "{{ nis_check.stdout if nis_check.rc == 0 else 'ypbind is not installed' }}"

# - name: Remove ypbind with --nogpgcheck (RHUI workaround)
#   shell: dnf remove -y ypbind --nogpgcheck
#   args:
#     executable: /bin/bash
#   ignore_errors: true

# - name: Ensure Telnet client is not installed
#   package:
#     name: telnet
#     state: absent
#   ignore_errors: true

# - name: Check if telnet is installed
#   shell: rpm -q telnet
#   register: telnet_check
#   ignore_errors: true

# - name: Report telnet client installation status
#   debug:
#     msg: "{{ telnet_check.stdout if telnet_check.rc == 0 else 'telnet is not installed' }}"

# - name: Check if telnet is installed
#   shell: rpm -q telnet
#   register: telnet_check
#   ignore_errors: true

# - name: Report telnet client installation status
#   debug:
#     msg: "{{ telnet_check.stdout if telnet_check.rc == 0 else 'telnet is not installed' }}"

# - name: Remove telnet with --nogpgcheck (for RHUI issues)
#   shell: dnf remove -y telnet --nogpgcheck
#   args:
#     executable: /bin/bash
#   ignore_errors: true

# - name: Ensure TFTP client is not installed
#   package:
#     name: tftp
#     state: absent
#   ignore_errors: true

# - name: Check if tftp is installed
#   shell: rpm -q tftp
#   register: tftp_check
#   ignore_errors: true

# - name: Report tftp client installation status
#   debug:
#     msg: "{{ tftp_check.stdout if tftp_check.rc == 0 else 'tftp is not installed' }}"

# - name: Remove tftp with --nogpgcheck (RHUI workaround)
#   shell: dnf remove -y tftp --nogpgcheck
#   args:
#     executable: /bin/bash
#   ignore_errors: true

# - name: Check if IPv6 is enabled
#   shell: |
#     if grep -Pqs '^\h*0\b' /sys/module/ipv6/parameters/disable; then
#       echo "IPv6 is enabled"
#     else
#       echo "IPv6 is not enabled"
#     fi
#   register: ipv6_status

# - name: Report IPv6 status
#   debug:
#     msg: "{{ ipv6_status.stdout }}"

# - name: Disable IPv6 via sysctl
#   sysctl:
#     name: net.ipv6.conf.all.disable_ipv6
#     value: '1'
#     state: present
#     sysctl_set: yes
#     reload: yes

# - name: Disable IPv6 on default interface
#   sysctl:
#     name: net.ipv6.conf.default.disable_ipv6
#     value: '1'
#     state: present
#     sysctl_set: yes
#     reload: yes

# - name: Disable IPv6 in GRUB
#   lineinfile:
#     path: /etc/default/grub
#     regexp: '^GRUB_CMDLINE_LINUX='
#     line: 'GRUB_CMDLINE_LINUX="ipv6.disable=1"'
#     backrefs: yes

# - name: Regenerate GRUB config
#   shell: grub2-mkconfig -o /boot/grub2/grub.cfg
#   when: ansible_facts['distribution'] == "RedHat"

# - name: CIS 3.1.2 - Unload wireless modules if currently loaded
#   shell: modprobe -r {{ item }}
#   args:
#     executable: /bin/bash
#   loop:
#     - iwlwifi
#     - ath9k
#     - ath10k_pci
#     - brcmfmac
#     - rt2800pci
#     - rtl8723be
#     - rtl8188ee
#     - b43
#   ignore_errors: true


# - name: CIS 3.1.3 - Check if bluez package is installed
#   shell: rpm -q bluez
#   register: bluez_status
#   ignore_errors: true
#   changed_when: false

# - name: CIS 3.1.3 - Remove bluez package if not required
#   package:
#     name: bluez
#     state: absent
#   when: bluez_status.rc == 0
#   ignore_errors: true

# - name: CIS 3.1.3 - Stop bluetooth service if bluez is required as dependency
#   systemd:
#     name: bluetooth.service
#     state: stopped
#     enabled: false
#     masked: true
#   when: bluez_status.rc == 0
#   ignore_errors: true

# - name: CIS 3.2.1 - Prevent DCCP kernel module from loading
#   copy:
#     dest: /etc/modprobe.d/dccp.conf
#     content: |
#       install dccp /bin/false
#       blacklist dccp
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.2.1 - Unload dccp module if loaded
#   shell: modprobe -r dccp
#   args:
#     executable: /bin/bash
#   register: unload_dccp
#   failed_when: false
#   changed_when: unload_dccp.rc == 0

# - name: CIS 3.2.2 - Prevent TIPC kernel module from loading
#   copy:
#     dest: /etc/modprobe.d/tipc.conf
#     content: |
#       install tipc /bin/false
#       blacklist tipc
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.2.2 - Unload tipc module if currently loaded
#   shell: modprobe -r tipc
#   args:
#     executable: /bin/bash
#   register: unload_tipc
#   failed_when: false
#   changed_when: unload_tipc.rc == 0

# - name: CIS 3.2.3 - Prevent RDS kernel module from loading
#   copy:
#     dest: /etc/modprobe.d/rds.conf
#     content: |
#       install rds /bin/false
#       blacklist rds
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.2.3 - Unload rds module if currently loaded
#   shell: modprobe -r rds
#   args:
#     executable: /bin/bash
#   register: unload_rds
#   failed_when: false
#   changed_when: unload_rds.rc == 0

# - name: CIS 3.2.4 - Prevent SCTP kernel module from loading
#   copy:
#     dest: /etc/modprobe.d/sctp.conf
#     content: |
#       install sctp /bin/false
#       blacklist sctp
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.2.4 - Unload SCTP module if currently loaded
#   shell: modprobe -r sctp
#   args:
#     executable: /bin/bash
#   register: unload_sctp
#   failed_when: false
#   changed_when: unload_sctp.rc == 0

# - name: CIS 3.3.1 - Ensure IPv4 and IPv6 IP forwarding is disabled in sysctl configuration
#   copy:
#     dest: /etc/sysctl.d/60-cis-ipforward.conf
#     content: |
#       net.ipv4.ip_forward = 0
#       net.ipv6.conf.all.forwarding = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.3.1 - Apply runtime setting for net.ipv4.ip_forward
#   sysctl:
#     name: net.ipv4.ip_forward
#     value: '0'
#     state: present
#     reload: yes

# - name: Check if IPv6 is enabled
#   command: sysctl -n net.ipv6.conf.all.disable_ipv6
#   register: ipv6_status
#   changed_when: false

# - name: CIS 3.3.1 - Apply runtime setting if IPv6 is enabled
#   sysctl:
#     name: net.ipv6.conf.all.forwarding
#     value: '0'
#     state: present
#     reload: yes
#   when: ipv6_status.stdout == "0"


# - name: CIS 3.3.2 - Disable ICMP redirect sending (persistent config)
#   copy:
#     dest: /etc/sysctl.d/60-cis-send-redirects.conf
#     content: |
#       net.ipv4.conf.all.send_redirects = 0
#       net.ipv4.conf.default.send_redirects = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 3.3.2 - Disable ICMP redirect sending (persistent config)"
#   copy:
#     dest: /etc/sysctl.d/60-cis-send-redirects.conf
#     content: |
#       net.ipv4.conf.all.send_redirects = 0
#       net.ipv4.conf.default.send_redirects = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 3.3.2 - Apply runtime setting: net.ipv4.conf.all.send_redirects"
#   sysctl:
#     name: net.ipv4.conf.all.send_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: "CIS 3.3.2 - Apply runtime setting: net.ipv4.conf.default.send_redirects"
#   sysctl:
#     name: net.ipv4.conf.default.send_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: "CIS 3.3.3 - Persistently set bogus ICMP error response ignore"
#   copy:
#     dest: /etc/sysctl.d/60-cis-icmp-ignore.conf
#     content: |
#       net.ipv4.icmp_ignore_bogus_error_responses = 1
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 3.3.3 - Apply runtime setting: net.ipv4.icmp_ignore_bogus_error_responses"
#   sysctl:
#     name: net.ipv4.icmp_ignore_bogus_error_responses
#     value: '1'
#     state: present
#     reload: yes

# - name: "CIS 3.3.4 - Persistently ignore broadcast ICMP requests"
#   copy:
#     dest: /etc/sysctl.d/60-cis-ignore-broadcast-icmp.conf
#     content: |
#       net.ipv4.icmp_echo_ignore_broadcasts = 1
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 3.3.4 - Apply runtime setting: net.ipv4.icmp_echo_ignore_broadcasts"
#   sysctl:
#     name: net.ipv4.icmp_echo_ignore_broadcasts
#     value: '1'
#     state: present
#     reload: yes

# - name: "CIS 3.3.5 - Persistently disable ICMP redirect acceptance"
#   copy:
#     dest: /etc/sysctl.d/60-cis-accept-redirects.conf
#     content: |
#       net.ipv4.conf.all.accept_redirects = 0
#       net.ipv4.conf.default.accept_redirects = 0
#       net.ipv6.conf.all.accept_redirects = 0
#       net.ipv6.conf.default.accept_redirects = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 3.3.5 - Apply runtime setting: net.ipv4.conf.all.accept_redirects"
#   sysctl:
#     name: net.ipv4.conf.all.accept_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: "CIS 3.3.5 - Apply runtime setting: net.ipv4.conf.default.accept_redirects"
#   sysctl:
#     name: net.ipv4.conf.default.accept_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: "CIS 3.3.5 - Apply runtime setting: net.ipv6.conf.all.accept_redirects"
#   sysctl:
#     name: net.ipv6.conf.all.accept_redirects
#     value: '0'
#     state: present
#     reload: yes
#   when: ansible_facts['sysctl']['net.ipv6.conf.all.disable_ipv6'] is defined and ansible_facts['sysctl']['net.ipv6.conf.all.disable_ipv6'] == '0'

# - name: "CIS 3.3.5 - Apply runtime setting: net.ipv6.conf.default.accept_redirects"
#   sysctl:
#     name: net.ipv6.conf.default.accept_redirects
#     value: '0'
#     state: present
#     reload: yes
#   when: ansible_facts['sysctl']['net.ipv6.conf.all.disable_ipv6'] is defined and ansible_facts['sysctl']['net.ipv6.conf.all.disable_ipv6'] == '0'

# - name: CIS 3.3.6 - Persistently disable secure ICMP redirects
#   copy:
#     dest: /etc/sysctl.d/60-cis-secure-redirects.conf
#     content: |
#       net.ipv4.conf.all.secure_redirects = 0
#       net.ipv4.conf.default.secure_redirects = 0
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.3.6 - Apply runtime setting net.ipv4.conf.all.secure_redirects
#   sysctl:
#     name: net.ipv4.conf.all.secure_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: CIS 3.3.6 - Apply runtime setting net.ipv4.conf.default.secure_redirects
#   sysctl:
#     name: net.ipv4.conf.default.secure_redirects
#     value: '0'
#     state: present
#     reload: yes

# - name: CIS 3.3.7 - Persistently enable reverse path filtering
#   copy:
#     dest: /etc/sysctl.d/60-cis-rpfilter.conf
#     content: |
#       net.ipv4.conf.all.rp_filter = 1
#       net.ipv4.conf.default.rp_filter = 1
#     owner: root
#     group: root
#     mode: '0644'

# - name: CIS 3.3.7 - Apply runtime setting net.ipv4.conf.all.rp_filter
#   sysctl:
#     name: net.ipv4.conf.all.rp_filter
#     value: '1'
#     state: present
#     reload: yes

# - name: CIS 3.3.7 - Apply runtime setting net.ipv4.conf.default.rp_filter
#   sysctl:
#     name: net.ipv4.conf.default.rp_filter
#     value: '1'
#     state: present
#     reload: yes

# # CIS 3.3.8 - Ensure source routed packets are not accepted

# # Step 1: Apply runtime sysctl settings for IPv4
# - name: CIS 3.3.8 - Apply runtime net.ipv4.conf.all.accept_source_route
#   ansible.posix.sysctl:
#     name: net.ipv4.conf.all.accept_source_route
#     value: '0'
#     state: present
#     reload: yes

# - name: CIS 3.3.8 - Apply runtime net.ipv4.conf.default.accept_source_route
#   ansible.posix.sysctl:
#     name: net.ipv4.conf.default.accept_source_route
#     value: '0'
#     state: present
#     reload: yes

# # Step 2: Apply persistent settings for IPv4
# - name: CIS 3.3.8 - Persist net.ipv4.conf.all.accept_source_route
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv4_sysctl.conf
#     regexp: '^net\.ipv4\.conf\.all\.accept_source_route'
#     line: 'net.ipv4.conf.all.accept_source_route = 0'
#     create: yes
#     mode: '0644'

# - name: CIS 3.3.8 - Persist net.ipv4.conf.default.accept_source_route
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv4_sysctl.conf
#     regexp: '^net\.ipv4\.conf\.default\.accept_source_route'
#     line: 'net.ipv4.conf.default.accept_source_route = 0'
#     create: yes
#     mode: '0644'

# # Step 3: Gather runtime sysctl values to check if IPv6 is enabled
# - name: CIS 3.3.8 - Gather sysctl values to determine if IPv6 is enabled
#   ansible.builtin.command: sysctl -a
#   register: sysctl_output
#   changed_when: false

# - name: CIS 3.3.8 - Set fact to detect if IPv6 is disabled
#   ansible.builtin.set_fact:
#     ipv6_disabled: "{{ 'net.ipv6.conf.all.disable_ipv6 = 1' in sysctl_output.stdout }}"

# # Step 4: Apply runtime sysctl settings for IPv6 if enabled
# - name: CIS 3.3.8 - Apply runtime net.ipv6.conf.all.accept_source_route (if IPv6 enabled)
#   ansible.posix.sysctl:
#     name: net.ipv6.conf.all.accept_source_route
#     value: '0'
#     state: present
#     reload: yes
#   when: not ipv6_disabled

# - name: CIS 3.3.8 - Apply runtime net.ipv6.conf.default.accept_source_route (if IPv6 enabled)
#   ansible.posix.sysctl:
#     name: net.ipv6.conf.default.accept_source_route
#     value: '0'
#     state: present
#     reload: yes
#   when: not ipv6_disabled

# # Step 5: Apply persistent settings for IPv6 if enabled
# - name: CIS 3.3.8 - Persist net.ipv6.conf.all.accept_source_route (if IPv6 enabled)
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv6_sysctl.conf
#     regexp: '^net\.ipv6\.conf\.all\.accept_source_route'
#     line: 'net.ipv6.conf.all.accept_source_route = 0'
#     create: yes
#     mode: '0644'
#   when: not ipv6_disabled

# - name: CIS 3.3.8 - Persist net.ipv6.conf.default.accept_source_route (if IPv6 enabled)
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv6_sysctl.conf
#     regexp: '^net\.ipv6\.conf\.default\.accept_source_route'
#     line: 'net.ipv6.conf.default.accept_source_route = 0'
#     create: yes
#     mode: '0644'
#   when: not ipv6_disabled


# # CIS 3.3.9 - Ensure suspicious packets are logged

# # Step 1: Apply runtime sysctl settings
# - name: CIS 3.3.9 - Apply runtime net.ipv4.conf.all.log_martians
#   ansible.posix.sysctl:
#     name: net.ipv4.conf.all.log_martians
#     value: '1'
#     state: present
#     reload: yes

# - name: CIS 3.3.9 - Apply runtime net.ipv4.conf.default.log_martians
#   ansible.posix.sysctl:
#     name: net.ipv4.conf.default.log_martians
#     value: '1'
#     state: present
#     reload: yes

# # Step 2: Apply persistent settings
# - name: CIS 3.3.9 - Persist net.ipv4.conf.all.log_martians
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv4_sysctl.conf
#     regexp: '^net\.ipv4\.conf\.all\.log_martians'
#     line: 'net.ipv4.conf.all.log_martians = 1'
#     create: yes
#     mode: '0644'

# - name: CIS 3.3.9 - Persist net.ipv4.conf.default.log_martians
#   ansible.builtin.lineinfile:
#     path: /etc/sysctl.d/60-netipv4_sysctl.conf
#     regexp: '^net\.ipv4\.conf\.default\.log_martians'
#     line: 'net.ipv4.conf.default.log_martians = 1'
#     create: yes
#     mode: '0644'

# # CIS 3.3.10 - Ensure tcp_syncookies is enabled (runtime and persistent)

# - name: "CIS 3.3.10 - Apply runtime: net.ipv4.tcp_syncookies"
#   ansible.posix.sysctl:
#     name: net.ipv4.tcp_syncookies
#     value: '1'
#     state: present
#     reload: yes

# - name: "CIS 3.3.10 - Ensure net.ipv4.tcp_syncookies is set persistently"
#   copy:
#     dest: /etc/sysctl.d/60-netipv4_sysctl.conf
#     content: |
#       net.ipv4.tcp_syncookies = 1
#   #notify: Reload sysctl

# # CIS 3.3.11 - Ensure IPv6 router advertisements are not accepted (if IPv6 is enabled)

# - name: "CIS 3.3.11 - Check if IPv6 is enabled"
#   ansible.builtin.slurp:
#     src: /sys/module/ipv6/parameters/disable
#   register: ipv6_status

# - name: "CIS 3.3.11 - Set runtime: net.ipv6.conf.all.accept_ra"
#   ansible.posix.sysctl:
#     name: net.ipv6.conf.all.accept_ra
#     value: '0'
#     state: present
#     reload: yes
#   when: ipv6_status['content'] | b64decode | trim == '0'

# - name: "CIS 3.3.11 - Set runtime: net.ipv6.conf.default.accept_ra"
#   ansible.posix.sysctl:
#     name: net.ipv6.conf.default.accept_ra
#     value: '0'
#     state: present
#     reload: yes
#   when: ipv6_status['content'] | b64decode | trim == '0'

# - name: "CIS 3.3.11 - Persist IPv6 accept_ra settings"
#   copy:
#     dest: /etc/sysctl.d/60-netipv6_sysctl.conf
#     content: |
#       net.ipv6.conf.all.accept_ra = 0
#       net.ipv6.conf.default.accept_ra = 0
#     owner: root
#     group: root
#     mode: '0644'
#   when: ipv6_status['content'] | b64decode | trim == '0'

# - name: "CIS 3.3.11 - Reload sysctl for IPv6 settings"
#   ansible.builtin.command: sysctl --system
#   when: ipv6_status['content'] | b64decode | trim == '0'

# # CIS 3.4.1.1 - Ensure nftables is installed

# - name: Install nftables without GPG check (not recommended)
#   ansible.builtin.command: dnf install -y --nogpgcheck nftables

# - name: Enable and start nftables
#   ansible.builtin.systemd:
#     name: nftables
#     enabled: true
#     state: started

# # CIS 3.4.1.2 - Ensure a single firewall configuration utility is in use
# - name: Check if firewalld is installed
#   ansible.builtin.shell: rpm -q firewalld
#   register: firewalld_check
#   ignore_errors: true

# - name: Check if nftables is installed
#   ansible.builtin.shell: rpm -q nftables
#   register: nftables_check
#   ignore_errors: true

# - name: Check if firewalld is active
#   ansible.builtin.shell: systemctl is-active firewalld
#   register: firewalld_active
#   changed_when: false
#   ignore_errors: true

# - name: Check if nftables is active
#   ansible.builtin.shell: systemctl is-active nftables
#   register: nftables_active
#   changed_when: false
#   ignore_errors: true

# - name: Check if firewalld is enabled
#   ansible.builtin.shell: systemctl is-enabled firewalld
#   register: firewalld_enabled
#   changed_when: false
#   ignore_errors: true

# - name: Check if nftables is enabled
#   ansible.builtin.shell: systemctl is-enabled nftables
#   register: nftables_enabled
#   changed_when: false
#   ignore_errors: true

# - name: Mask and stop firewalld if both firewalld and nftables are active
#   ansible.builtin.systemd:
#     name: firewalld
#     enabled: false
#     masked: true
#     state: stopped
#   when: 
#     - firewalld_active.stdout == "active"
#     - nftables_active.stdout == "active"
#     - nftables_enabled.stdout == "enabled"

# - name: Mask and stop nftables if both firewalld and nftables are active
#   ansible.builtin.systemd:
#     name: nftables
#     enabled: false
#     masked: true
#     state: stopped
#   when: 
#     - firewalld_active.stdout == "active"
#     - nftables_active.stdout == "active"
#     - firewalld_enabled.stdout == "enabled"

# - name: Ensure nftables is installed if neither firewall is present
#   ansible.builtin.yum:
#     name: nftables
#     state: present
#   when:
#     - "'is not installed' in firewalld_check.stderr"
#     - "'is not installed' in nftables_check.stderr"

# - name: CIS 3.4.2 - Create nftables rules directory
#   file:
#     path: /etc/nftables
#     state: directory
#     owner: root
#     group: root
#     mode: '0755'

# - name: CIS 3.4.2 - Write nftables rules to file
#   copy:
#     dest: /etc/nftables/nftables.rules
#     owner: root
#     group: root
#     mode: '0600'
#     content: |
#       flush ruleset

#       table inet filter {
#           chain input {
#               type filter hook input priority 0; policy drop;

#               ct state invalid drop
#               iif lo accept
#               iif != lo ip daddr 127.0.0.1/8 drop
#               iif != lo ip6 daddr ::1/128 drop

#               ip protocol tcp ct state established accept
#               ip protocol udp ct state established accept

#               ip protocol igmp accept
#               tcp dport ssh accept

#               icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem,
#               mld-listener-query, mld-listener-report, mld-listener-done, nd-router-solicit, nd-router-advert,
#               nd-neighbor-solicit, nd-neighbor-advert, ind-neighbor-solicit, ind-neighbor-advert, mld2-listener-report } accept

#               icmp type { destination-unreachable, router-advertisement, router-solicitation,
#               time-exceeded, parameter-problem } accept
#           }

#           chain forward {
#               type filter hook forward priority 0; policy drop;
#           }

#           chain output {
#               type filter hook output priority 0; policy accept;
#           }
#       }

# - name: CIS 3.4.2 - Apply nftables ruleset
#   command: nft -f /etc/nftables/nftables.rules

# - name: CIS 3.4.2 - Persist nftables rules
#   command: bash -c 'nft list ruleset > /etc/nftables/nftables.rules'

# - name: CIS 3.4.2 - Add include directive to nftables config
#   lineinfile:
#     path: /etc/sysconfig/nftables.conf
#     line: 'include "/etc/nftables/nftables.rules"'
#     create: yes
#     state: present

# - name: CIS 3.4.2 - Restart nftables to apply config
#   systemd:
#     name: nftables
#     enabled: true
#     state: restarted

# - name: Ensure python3-firewall is installed (required for firewalld module)
#   ansible.builtin.package:
#     name: python3-firewall
#     state: present
#   when: ansible_facts.services['firewalld.service'] is defined and ansible_facts.services['firewalld.service'].state == 'running'

# - name: CIS 3.4.2.3 - Remove unnecessary firewalld services
#   ansible.posix.firewalld:
#     service: "{{ item }}"
#     state: disabled
#     permanent: true
#     immediate: true
#   loop:
#     - cockpit
#     - dhcpv6-client
#     - ftp
#     - samba
#   when: ansible_facts.services['firewalld.service'] is defined and ansible_facts.services['firewalld.service'].state == 'running'
#   #notify: Reload firewalld
# - name: CIS 3.4.2.4 - Allow established connections in nftables
#   block:
#     - name: Check if nftables service is enabled
#       ansible.builtin.command: systemctl is-enabled nftables.service
#       register: nftables_status
#       changed_when: false
#       failed_when: false

#     - name: Allow established TCP connections in nftables
#       ansible.builtin.command: >
#         nft add rule inet filter input ip protocol tcp ct state established accept
#       when: nftables_status.stdout == "enabled"

#     - name: Allow established UDP connections in nftables
#       ansible.builtin.command: >
#         nft add rule inet filter input ip protocol udp ct state established accept
#       when: nftables_status.stdout == "enabled"

#     - name: Allow established ICMP connections in nftables
#       ansible.builtin.command: >
#         nft add rule inet filter input ip protocol icmp ct state established accept
#       when: nftables_status.stdout == "enabled"

# # - name: CIS 3.4.2.5 - Set default DROP policy for nftables base chains
# #   block:
# #     - name: Check if nftables service is enabled
# #       ansible.builtin.command: systemctl is-enabled nftables.service
# #       register: nftables_enabled
# #       changed_when: false
# #       failed_when: false

# #     - name: Set input chain default policy to DROP
# #       ansible.builtin.command: >
# #         nft chain inet filter input { policy drop \; }
# #       when: nftables_enabled.stdout == "enabled"

# #     - name: Set forward chain default policy to DROP
# #       ansible.builtin.command: >
# #         nft chain inet filter forward { policy drop \; }
# #       when: nftables_enabled.stdout == "enabled"

# #     - name: Set output chain default policy to DROP
# #       ansible.builtin.command: >
# #         nft chain inet filter output { policy drop \; }
# #       when: nftables_enabled.stdout == "enabled"

# - name: CIS 4.1.1.1 - Ensure cron daemon is enabled and active
#   block:
#     - name: Check if crond is installed
#       ansible.builtin.shell: rpm -q cronie
#       register: cronie_installed
#       changed_when: false
#       failed_when: cronie_installed.rc != 0

#     - name: Unmask crond service
#       ansible.builtin.systemd:
#         name: crond
#         state: started
#         enabled: true
#         masked: no
#       when: cronie_installed.rc == 0

# - name: CIS 4.1.1.2 - Ensure permissions on /etc/crontab are configured
#   block:
#     - name: Ensure /etc/crontab is owned by root
#       ansible.builtin.file:
#         path: /etc/crontab
#         owner: root
#         group: root
#         state: file

#     - name: Ensure /etc/crontab has 0600 permissions
#       ansible.builtin.file:
#         path: /etc/crontab
#         mode: '0600'
#         state: file

# - name: CIS 4.1.1.3 - Ensure permissions on /etc/cron.hourly are configured
#   block:
#     - name: Ensure /etc/cron.hourly is owned by root
#       ansible.builtin.file:
#         path: /etc/cron.hourly
#         owner: root
#         group: root
#         state: directory

#     - name: Ensure /etc/cron.hourly has 0700 permissions
#       ansible.builtin.file:
#         path: /etc/cron.hourly
#         mode: '0700'
#         state: directory

# - name: CIS 4.1.1.5 - Ensure permissions on /etc/cron.weekly are configured
#   block:
#     - name: Ensure /etc/cron.weekly is owned by root
#       ansible.builtin.file:
#         path: /etc/cron.weekly
#         owner: root
#         group: root
#         state: directory

#     - name: Ensure /etc/cron.weekly has 0700 permissions
#       ansible.builtin.file:
#         path: /etc/cron.weekly
#         mode: '0700'
#         state: directory

# - name: CIS 4.1.1.6 - Ensure permissions on /etc/cron.monthly are configured
#   block:
#     - name: Ensure /etc/cron.monthly is owned by root
#       ansible.builtin.file:
#         path: /etc/cron.monthly
#         owner: root
#         group: root
#         state: directory

#     - name: Ensure /etc/cron.monthly has 0700 permissions
#       ansible.builtin.file:
#         path: /etc/cron.monthly
#         mode: '0700'
#         state: directory

# - name: CIS 4.1.1.7 - Ensure permissions on /etc/cron.d are configured
#   block:
#     - name: Ensure /etc/cron.d is owned by root
#       ansible.builtin.file:
#         path: /etc/cron.d
#         owner: root
#         group: root
#         state: directory

#     - name: Ensure /etc/cron.d has 0700 permissions
#       ansible.builtin.file:
#         path: /etc/cron.d
#         mode: '0700'
#         state: directory

# - name: CIS 4.1.1.8 - Ensure crontab is restricted to authorized users
#   block:
#     - name: Ensure /etc/cron.allow exists
#       ansible.builtin.file:
#         path: /etc/cron.allow
#         state: touch
#         owner: root
#         group: root
#         mode: '0640'

#     - name: Ensure /etc/cron.deny is owned by root and permissions are 0640 if it exists
#       ansible.builtin.file:
#         path: /etc/cron.deny
#         owner: root
#         group: root
#         mode: '0640'
#         state: file
#       when: ansible_facts['os_family'] == "Debian" or ansible_facts['distribution'] == "Ubuntu"
#       ignore_errors: true

# - name: CIS 4.1.2.1 - Ensure 'at' is restricted to authorized users
#   block:

#     - name: Check if 'daemon' group exists
#       ansible.builtin.getent:
#         database: group
#       register: getent_groups

#     - name: Set group variable for 'at' permission files
#       set_fact:
#         at_group: "{{ 'daemon' if getent_groups.ansible_facts.getent_group['daemon'] is defined else 'root' }}"

#     - name: Ensure /etc/at.allow exists with correct permissions
#       ansible.builtin.file:
#         path: /etc/at.allow
#         state: touch
#         owner: root
#         group: "{{ at_group }}"
#         mode: '0640'

#     - name: Check if /etc/at.deny exists
#       ansible.builtin.stat:
#         path: /etc/at.deny
#       register: at_deny_stat

#     - name: Ensure /etc/at.deny has correct permissions if it exists
#       ansible.builtin.file:
#         path: /etc/at.deny
#         state: file
#         owner: root
#         group: "{{ at_group }}"
#         mode: '0640'
#       when: at_deny_stat.stat.exists

# - name: CIS 4.2.1 - Ensure permissions on SSH configuration files
#   block:

#     - name: Ensure /etc/ssh/sshd_config has correct permissions
#       ansible.builtin.file:
#         path: /etc/ssh/sshd_config
#         state: file
#         owner: root
#         group: root
#         mode: '0600'

#     - name: Check if /etc/ssh/sshd_config.d exists and is a directory
#       ansible.builtin.stat:
#         path: /etc/ssh/sshd_config.d
#       register: sshd_config_d_stat

#     - name: Find *.conf files under /etc/ssh/sshd_config.d/
#       ansible.builtin.find:
#         paths: /etc/ssh/sshd_config.d/
#         patterns: '*.conf'
#         file_type: file
#       register: sshd_conf_files
#       when: sshd_config_d_stat.stat.isdir is defined and sshd_config_d_stat.stat.isdir

#     - name: Set permissions on each file in /etc/ssh/sshd_config.d/
#       ansible.builtin.file:
#         path: "{{ item.path }}"
#         state: file
#         owner: root
#         group: root
#         mode: '0600'
#       loop: "{{ sshd_conf_files.files }}"
#       when:
#         - sshd_config_d_stat.stat.isdir is defined and sshd_config_d_stat.stat.isdir
#         - sshd_conf_files.matched > 0

# # - name: Ensure all files in /etc/ssh/sshd_config.d have 0600 permissions
# #   ansible.builtin.shell: |
# #     chmod 600 /etc/ssh/sshd_config.d/*
# #   args:
# #     executable: /bin/bash
# #   when: ansible_facts['os_family'] == "RedHat"

# - name: CIS 4.2.2 - Set permissions on SSH private host key files
#   block:
#     - name: Find SSH private key files under /etc/ssh
#       ansible.builtin.find:
#         paths: /etc/ssh
#         file_type: file
#         patterns: 'ssh_host_*_key'
#         recurse: no
#       register: ssh_private_keys

#     - name: Ensure ownership and permissions on SSH private key files
#       ansible.builtin.file:
#         path: "{{ item.path }}"
#         owner: root
#         group: root
#         mode: '0600'
#       loop: "{{ ssh_private_keys.files }}"
#       when: ssh_private_keys.matched > 0



# - name: CIS 4.2.3 - Set permissions on SSH public host key files
#   block:
#     - name: Find SSH public key files under /etc/ssh
#       ansible.builtin.find:
#         paths: /etc/ssh
#         file_type: file
#         patterns: 'ssh_host_*_key.pub'
#         recurse: no
#       register: ssh_public_keys

#     - name: Ensure ownership and permissions on SSH public key files
#       ansible.builtin.file:
#         path: "{{ item.path }}"
#         owner: root
#         group: root
#         mode: '0644'
#       loop: "{{ ssh_public_keys.files }}"
#       when: ssh_public_keys.matched > 0

# - name: CIS 4.2.4 - Restrict SSH access to specific users using AllowUsers
#   block:
#     - name: Ensure admin user exists
#       ansible.builtin.user:
#         name: adminuser
#         state: present

#     - name: Insert AllowUsers before any Include directives in sshd_config
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^AllowUsers'
#         line: 'AllowUsers adminuser'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Ensure SSHD is reloaded to apply config
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.5 - Ensure sshd Banner is configured"
#   block:
#     - name: Ensure /etc/issue.net exists with legal warning
#       ansible.builtin.copy:
#         dest: /etc/issue.net
#         content: |
#           WARNING: Unauthorized access to this system is prohibited.
#           All activity will be monitored and reported.

#     - name: Configure Banner in sshd_config above any Include
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^Banner'
#         line: 'Banner /etc/issue.net'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload SSH service to apply Banner config
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded


# - name: "CIS 4.2.6 - Ensure only strong SSH Ciphers are used"
#   block:
#     - name: Add line to disable weak SSH ciphers above any Include
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^Ciphers'
#         line: 'Ciphers -3des-cbc,aes128-cbc,aes192-cbc,aes256-cbc,rijndael-cbc@lysator.liu.se'
#         insertafter: '^#?Port.*'
#         state: present
#         backup: yes

#     # - name: Reload SSH service to apply cipher config
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.7 - Ensure sshd ClientAliveInterval and ClientAliveCountMax are configured"
#   block:
#     - name: Set ClientAliveInterval to 15
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^ClientAliveInterval'
#         line: 'ClientAliveInterval 15'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     - name: Set ClientAliveCountMax to 3
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^ClientAliveCountMax'
#         line: 'ClientAliveCountMax 3'
#         insertafter: '^ClientAliveInterval.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload SSHD to apply keepalive configuration
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.8 - Ensure sshd DisableForwarding is enabled"
#   block:
#     - name: "Ensure 'DisableForwarding yes' is set in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^DisableForwarding'
#         line: 'DisableForwarding yes'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload sshd to apply DisableForwarding configuration
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.9 - Ensure sshd HostbasedAuthentication is disabled"
#   block:
#     - name: "Ensure 'HostbasedAuthentication no' is set in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^HostbasedAuthentication'
#         line: 'HostbasedAuthentication no'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload sshd to apply HostbasedAuthentication configuration
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.10 - Ensure sshd IgnoreRhosts is enabled"
#   block:
#     - name: "Ensure 'IgnoreRhosts yes' is set in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^IgnoreRhosts'
#         line: 'IgnoreRhosts yes'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload sshd to apply IgnoreRhosts setting
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.11 - Ensure sshd KexAlgorithms is configured to disable weak algorithms"
#   block:
#     - name: "Add or update KexAlgorithms line to disable weak algorithms"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^KexAlgorithms'
#         line: 'KexAlgorithms -diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: Reload sshd to apply updated KexAlgorithms setting
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.12 - Ensure sshd LoginGraceTime is set to 60 seconds"
#   block:
#     - name: "Set LoginGraceTime to 60 in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^LoginGraceTime'
#         line: 'LoginGraceTime 60'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply LoginGraceTime setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.13 - Ensure sshd LogLevel is set to VERBOSE"
#   block:
#     - name: "Set LogLevel to VERBOSE in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^LogLevel'
#         line: 'LogLevel VERBOSE'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply LogLevel setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.14 - Ensure sshd MACs are configured to disable weak algorithms"
#   block:
#     - name: "Set strong MACs in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^MACs'
#         line: >
#           MACs -hmac-md5,hmac-md5-96,hmac-ripemd160,hmac-sha1-96,
#           umac-64@openssh.com,hmac-md5-etm@openssh.com,
#           hmac-md5-96-etm@openssh.com,hmac-ripemd160-etm@openssh.com,
#           hmac-sha1-96-etm@openssh.com,umac-64-etm@openssh.com
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply MACs setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.15 - Ensure sshd MaxAuthTries is configured to 4 or less"
#   block:
#     - name: "Set MaxAuthTries to 4 in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^MaxAuthTries'
#         line: 'MaxAuthTries 4'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply MaxAuthTries setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.16 - Ensure sshd MaxSessions is configured to 10 or less"
#   block:
#     - name: "Set MaxSessions to 10 in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^MaxSessions'
#         line: 'MaxSessions 10'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply MaxSessions setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.17 - Ensure sshd MaxStartups is configured to 10:30:60 or more restrictive"
#   block:
#     - name: "Set MaxStartups to 10:30:60 in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^MaxStartups'
#         line: 'MaxStartups 10:30:60'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply MaxStartups setting"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.18 - Ensure sshd PermitEmptyPasswords is disabled"
#   block:
#     - name: "Set 'PermitEmptyPasswords no' in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^PermitEmptyPasswords'
#         line: 'PermitEmptyPasswords no'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply PermitEmptyPasswords change"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.20 - Ensure sshd PermitUserEnvironment is disabled"
#   block:
#     - name: "Set 'PermitUserEnvironment no' in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^PermitUserEnvironment'
#         line: 'PermitUserEnvironment no'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply PermitUserEnvironment change"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.2.21 - Ensure sshd UsePAM is enabled"
#   block:
#     - name: "Set 'UsePAM yes' in /etc/ssh/sshd_config"
#       ansible.builtin.lineinfile:
#         path: /etc/ssh/sshd_config
#         regexp: '^UsePAM'
#         line: 'UsePAM yes'
#         insertafter: '^#?Port.*'
#         state: present
#         create: yes
#         backup: yes

#     # - name: "Reload sshd to apply UsePAM configuration"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded
# - name: "CIS 4.2.22 - Ensure sshd CRYPTO_POLICY is not set in /etc/sysconfig/sshd"
#   block:
#     - name: "Comment out CRYPTO_POLICY variable in /etc/sysconfig/sshd if present"
#       ansible.builtin.replace:
#         path: /etc/sysconfig/sshd
#         regexp: '^\s*(CRYPTO_POLICY\s*=.*)$'
#         replace: '# \1'
#         backup: yes

#     # - name: "Reload sshd to apply changes"
#     #   ansible.builtin.service:
#     #     name: sshd
#     #     state: reloaded

# - name: "CIS 4.3.1 - Check if sudo is installed"
#   ansible.builtin.command: rpm -q sudo
#   register: sudo_check
#   ignore_errors: true
#   args:
#     warn: false


# - name: "CIS 4.3.2 - Ensure sudo commands use pty"
#   ansible.builtin.lineinfile:
#     path: /etc/sudoers.d/01_cis_use_pty
#     create: yes
#     mode: '0440'
#     owner: root
#     group: root
#     line: 'Defaults use_pty'
#     validate: '/usr/sbin/visudo -cf %s'

# - name: "CIS 4.3.3 - Ensure sudo log file is configured"
#   ansible.builtin.lineinfile:
#     path: /etc/sudoers.d/02_cis_sudo_logfile
#     create: yes
#     mode: '0440'
#     owner: root
#     group: root
#     line: 'Defaults logfile="/var/log/sudo.log"'
#     validate: '/usr/sbin/visudo -cf %s'

# - name: "CIS 4.3.3 - Ensure sudo log file exists"
#   ansible.builtin.file:
#     path: /var/log/sudo.log
#     state: touch
#     owner: root
#     group: root
#     mode: '0600'

# - name: "CIS 4.3.5 - Remove !authenticate from /etc/sudoers and /etc/sudoers.d/*"
#   ansible.builtin.replace:
#     path: "{{ item }}"
#     regexp: '\!authenticate'
#     replace: ''
#     validate: '/usr/sbin/visudo -cf %s'
#   loop: "{{ ['/etc/sudoers'] + (lookup('ansible.builtin.fileglob', '/etc/sudoers.d/*', wantlist=True) | default([])) }}"
#   when: ansible_facts['os_family'] == 'RedHat'


# - name: "CIS 4.3.6 - Ensure sudo authentication timeout is set to 15 minutes or less"
#   ansible.builtin.lineinfile:
#     path: /etc/sudoers.d/10-cis-timeout
#     create: yes
#     mode: '0440'
#     owner: root
#     group: root
#     line: 'Defaults timestamp_timeout=15'
#     validate: '/usr/sbin/visudo -cf %s'

# - name: "CIS 4.3.7 - Create a group to restrict 'su' access"
#   ansible.builtin.group:
#     name: sugroup
#     state: present
#     system: true

# - name: "CIS 4.3.7 - Ensure pam_wheel.so is configured with use_uid and group=sugroup"
#   ansible.builtin.lineinfile:
#     path: /etc/pam.d/su
#     regexp: '^#?auth\s+required\s+pam_wheel\.so.*'
#     line: 'auth required pam_wheel.so use_uid group=sugroup'
#     state: present
#     backrefs: yes
#     create: yes

# - name: "CIS 4.3.7 - Ensure 'sugroup' has no users"
#   ansible.builtin.command: "gpasswd -M '' sugroup"
#   changed_when: false

# - name: "CIS 4.4.1.1 - Ensure latest version of pam is installed using --nogpgcheck"
#   ansible.builtin.command: dnf upgrade -y pam --nogpgcheck
#   register: pam_upgrade
#   changed_when: "'Nothing to do' not in pam_upgrade.stdout"

# - name: "CIS 4.4.1.2 - Ensure latest version of authselect is installed using --nogpgcheck"
#   ansible.builtin.command: dnf upgrade -y authselect --nogpgcheck
#   register: authselect_upgrade
#   changed_when: "'Nothing to do' not in authselect_upgrade.stdout"

# - name: "CIS 4.4.2 - Create custom authselect profile"
#   ansible.builtin.command: >
#     authselect create-profile custom-profile -b sssd --symlink-meta
#   args:
#     creates: /etc/authselect/custom/custom-profile

# - name: "CIS 4.4.2 - Apply custom authselect profile with security features"
#   ansible.builtin.command: >
#     authselect select custom/custom-profile
#     with-faillock
#     with-sudo
#     without-nullok
#     --force
#   register: authselect_configure

# - name: "CIS 4.4.2 - Validate applied authselect profile"
#   ansible.builtin.command: authselect current
#   register: authselect_status

# - name: "Debug - Show current authselect status"
#   ansible.builtin.debug:
#     var: authselect_status.stdout

# - name: "CIS 4.4.2.1 - Create a custom authselect profile if it doesn't exist"
#   ansible.builtin.command: authselect create-profile custom-profile -b sssd
#   args:
#     creates: /etc/authselect/custom/custom-profile

# - name: "CIS 4.4.2.1 - Enable custom profile with required features"
#   ansible.builtin.command: >
#     authselect select custom/custom-profile
#     with-pwhistory
#     with-faillock
#     without-nullok
#     --backup=PAM_CONFIG_BACKUP
#     --force
#   register: authselect_select

# - name: "CIS 4.4.2.1 - Apply changes to reflect updated PAM templates"
#   ansible.builtin.command: authselect apply-changes

# - name: "CIS 4.4.2.1 - Verify required PAM modules are included in password-auth"
#   ansible.builtin.shell: >
#     grep -P --quiet '\b(pam_pwquality\.so|pam_pwhistory\.so|pam_faillock\.so|pam_unix\.so)\b'
#     /etc/authselect/custom/custom-profile/password-auth
#   register: pam_check_password_auth
#   failed_when: pam_check_password_auth.rc != 0

# - name: "CIS 4.4.2.1 - Verify required PAM modules are included in system-auth"
#   ansible.builtin.shell: >
#     grep -P --quiet '\b(pam_pwquality\.so|pam_pwhistory\.so|pam_faillock\.so|pam_unix\.so)\b'
#     /etc/authselect/custom/custom-profile/system-auth
#   register: pam_check_system_auth
#   failed_when: pam_check_system_auth.rc != 0

# - name: "CIS 4.4.2.2 - Ensure 'with-faillock' feature is enabled in authselect"
#   ansible.builtin.command: >
#     authselect enable-feature with-faillock
#   register: faillock_feature
#   changed_when: "'with-faillock' in faillock_feature.stdout"

# - name: "CIS 4.4.2.2 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes

# - name: "CIS 4.4.2.2 - Verify pam_faillock.so present in password-auth"
#   ansible.builtin.shell: >
#     grep -Pq '\bpam_faillock\.so\b'
#     /etc/authselect/custom/custom-profile/password-auth
#   register: faillock_check_password
#   failed_when: faillock_check_password.rc != 0
#   changed_when: false

# - name: "CIS 4.4.2.2 - Verify pam_faillock.so present in system-auth"
#   ansible.builtin.shell: >
#     grep -Pq '\bpam_faillock\.so\b'
#     /etc/authselect/custom/custom-profile/system-auth
#   register: faillock_check_system
#   failed_when: faillock_check_system.rc != 0
#   changed_when: false

# - name: "Select custom authselect profile with supported features"
#   ansible.builtin.command: >
#     authselect select custom/custom-profile
#     with-faillock with-pwhistory
#     --force --backup=before-custom-profile

# - name: "Ensure pam_pwquality.so line is present in password-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/password-auth
#     regexp: '^password\s+requisite\s+pam_pwquality\.so'
#     line: 'password    requisite    pam_pwquality.so local_users_only'
#     insertafter: EOF

# - name: "Ensure pam_pwquality.so line is present in system-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/system-auth
#     regexp: '^password\s+requisite\s+pam_pwquality\.so'
#     line: 'password    requisite    pam_pwquality.so local_users_only'
#     insertafter: EOF

# - name: "Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes


# - name: "CIS 4.4.2.4 - Enable 'with-pwhistory' feature in authselect"
#   ansible.builtin.command: authselect enable-feature with-pwhistory
#   register: pwhistory_feature
#   changed_when: "'with-pwhistory' in pwhistory_feature.stdout"

# - name: "CIS 4.4.2.4 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes

# - name: "CIS 4.4.2.4 - Verify pam_pwhistory.so is present in password-auth"
#   ansible.builtin.shell: >
#     grep -Pq '\bpam_pwhistory\.so\b'
#     /etc/authselect/custom/custom-profile/password-auth
#   register: pwhistory_check_password
#   failed_when: pwhistory_check_password.rc != 0
#   changed_when: false

# - name: "CIS 4.4.2.4 - Verify pam_pwhistory.so is present in system-auth"
#   ansible.builtin.shell: >
#     grep -Pq '\bpam_pwhistory\.so\b'
#     /etc/authselect/custom/custom-profile/system-auth
#   register: pwhistory_check_system
#   failed_when: pwhistory_check_system.rc != 0
#   changed_when: false

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so auth line is present in password-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/password-auth
#     regexp: '^\s*auth\s+sufficient\s+pam_unix\.so'
#     line: 'auth        sufficient    pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so account line is present in password-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/password-auth
#     regexp: '^\s*account\s+required\s+pam_unix\.so'
#     line: 'account     required      pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so password line is present in password-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/password-auth
#     regexp: '^\s*password\s+sufficient\s+pam_unix\.so'
#     line: 'password    sufficient    pam_unix.so sha512 shadow use_authtok'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so session line is present in password-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/password-auth
#     regexp: '^\s*session\s+required\s+pam_unix\.so'
#     line: 'session     required      pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so auth line is present in system-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/system-auth
#     regexp: '^\s*auth\s+sufficient\s+pam_unix\.so'
#     line: 'auth        sufficient    pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so account line is present in system-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/system-auth
#     regexp: '^\s*account\s+required\s+pam_unix\.so'
#     line: 'account     required      pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so password line is present in system-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/system-auth
#     regexp: '^\s*password\s+sufficient\s+pam_unix\.so'
#     line: 'password    sufficient    pam_unix.so sha512 shadow use_authtok'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Ensure pam_unix.so session line is present in system-auth"
#   ansible.builtin.lineinfile:
#     path: /etc/authselect/custom/custom-profile/system-auth
#     regexp: '^\s*session\s+required\s+pam_unix\.so'
#     line: 'session     required      pam_unix.so'
#     insertafter: EOF

# - name: "CIS 4.4.2.5 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes

# - name: "CIS 4.4.3.1 - Configure pam_faillock in /etc/security/faillock.conf"
#   ansible.builtin.blockinfile:
#     path: /etc/security/faillock.conf
#     create: true
#     block: |
#       deny=5
#       fail_interval=900
#       unlock_time=900
#       even_deny_root
#       root_unlock_time=900
#       local_users_only
#       audit
#   tags:
#     - CIS_4.4.3.1

# - name: "Set correct permissions for /etc/security/faillock.conf"
#   ansible.builtin.file:
#     path: /etc/security/faillock.conf
#     owner: root
#     group: root
#     mode: '0644'
#   tags:
#     - CIS_4.4.3.1

# - name: "CIS 4.4.3.1.1 - Ensure 'deny = 5' is set in /etc/security/faillock.conf"
#   ansible.builtin.lineinfile:
#     path: /etc/security/faillock.conf
#     regexp: '^deny\s*='
#     line: 'deny = 5'
#     create: yes
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.1.1 - Remove deny= option from pam_faillock.so lines in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_faillock\.so.*)\s+deny\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes

# - name: "CIS 4.4.3.1.1 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   register: authselect_changes
#   changed_when: "'No changes detected' not in authselect_changes.stdout"

# - name: "CIS 4.4.3.1.1 - Verify 'deny=5' is effective"
#   ansible.builtin.shell: grep -Pi -- '^\h*deny\h*=\h*[1-5]\b' /etc/security/faillock.conf
#   register: deny_value
#   changed_when: false
#   failed_when: deny_value.rc != 0

# - name: "CIS 4.4.3.1.1 - Ensure no 'deny=' remains in PAM faillock lines"
#   ansible.builtin.shell: >
#     grep -Pi -- '^\h*auth\h+(requisite|required|sufficient)\h+pam_faillock\.so\h+([^#\n\r]+\h+)?deny\h*=\h*(0|[6-9]|[1-9][0-9]+)\b'
#     /etc/authselect/custom/custom-profile/system-auth
#     /etc/authselect/custom/custom-profile/password-auth || true
#   register: pam_deny_check
#   changed_when: false
#   failed_when: pam_deny_check.stdout != ""

# - name: "CIS 4.4.3.1.2 - Set unlock_time to 900 in /etc/security/faillock.conf"
#   ansible.builtin.lineinfile:
#     path: /etc/security/faillock.conf
#     regexp: '^\s*unlock_time\s*='
#     line: 'unlock_time = 900'
#     create: yes
#     state: present
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.1.2 - Remove unlock_time= option from pam_faillock.so lines in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_faillock\.so.*)\s+unlock_time\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.1.2 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.1.3 - Ensure even_deny_root is set in /etc/security/faillock.conf"
#   ansible.builtin.lineinfile:
#     path: /etc/security/faillock.conf
#     regexp: '^\s*even_deny_root'
#     line: 'even_deny_root'
#     create: yes
#     state: present
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.1.3 - Ensure root_unlock_time is set to 60 or more in /etc/security/faillock.conf"
#   ansible.builtin.lineinfile:
#     path: /etc/security/faillock.conf
#     regexp: '^\s*root_unlock_time\s*='
#     line: 'root_unlock_time = 60'
#     create: yes
#     state: present
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.1.3 - Remove even_deny_root from pam_faillock.so lines in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_faillock\.so.*)\s+even_deny_root(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.1.3 - Remove root_unlock_time from pam_faillock.so lines in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_faillock\.so.*)\s+root_unlock_time\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.1.3 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.1 - Comment out existing difok in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*difok\s*='
#     replace: '# difok ='
#   when: ansible_facts['distribution'] == "RedHat"

# - name: "CIS 4.4.3.2.1 - Ensure difok = 2 in /etc/security/pwquality.conf.d/50-pwdifok.conf"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwdifok.conf
#     create: yes
#     block: |
#       difok = 2
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.2.1 - Remove difok argument from pam_pwquality.so line in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+difok\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.1 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.2 - Comment out existing minlen in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*minlen\s*='
#     replace: '# minlen ='
#   when: ansible_facts['distribution'] == "RedHat"

# - name: "CIS 4.4.3.2.2 - Ensure minlen = 14 in /etc/security/pwquality.conf.d/50-pwlength.conf"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwlength.conf
#     create: yes
#     block: |
#       minlen = 14
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.2.2 - Remove minlen argument from pam_pwquality.so in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+minlen\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.2 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.3 - Comment out existing minclass and credits in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*(minclass|dcredit|ucredit|lcredit|ocredit)\s*='
#     replace: '# \1 ='
#   loop:
#     - minclass
#     - dcredit
#     - ucredit
#     - lcredit
#     - ocredit
#   loop_control:
#     loop_var: item

# - name: "CIS 4.4.3.2.3 - Configure password complexity in pwquality.conf.d"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwcomplexity.conf
#     create: yes
#     block: |
#       minclass = 4
#       dcredit = -1
#       ucredit = -1
#       lcredit = -1
#       ocredit = -1
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.2.3 - Remove minclass and credits from pam_pwquality.so arguments"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+(minclass|dcredit|ucredit|lcredit|ocredit)\s*=\s*\S+(.*)$'
#     line: '\1\3'
#     backrefs: yes
#     state: present
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.3 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.4 - Comment out existing maxrepeat in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*maxrepeat\s*='
#     replace: '# maxrepeat ='

# - name: "CIS 4.4.3.2.4 - Set maxrepeat = 3 in pwquality.conf.d"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwrepeat.conf
#     create: yes
#     block: |
#       maxrepeat = 3
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.2.4 - Remove maxrepeat argument from pam_pwquality.so in PAM profiles"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+maxrepeat\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#     state: present
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.4 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.5 - Comment out existing maxsequence in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*maxsequence\s*='
#     replace: '# maxsequence ='

# - name: "CIS 4.4.3.2.5 - Set maxsequence = 3 in pwquality.conf.d"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwmaxsequence.conf
#     create: yes
#     block: |
#       maxsequence = 3
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.2.5 - Remove maxsequence argument from pam_pwquality.so in PAM profiles"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+maxsequence\s*=\s*\S+(.*)$'
#     line: '\1\2'
#     backrefs: yes
#     state: present
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.5 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.6 - Comment out any dictcheck = 0 in pwquality.conf"
#   ansible.builtin.replace:
#     path: /etc/security/pwquality.conf
#     regexp: '^\s*dictcheck\s*=\s*0\b'
#     replace: '# dictcheck = 0'
#   ignore_errors: yes

# - name: "CIS 4.4.3.2.6 - Comment out dictcheck = 0 in all pwquality.conf.d files"
#   ansible.builtin.shell: |
#     find /etc/security/pwquality.conf.d/ -type f -name "*.conf" -exec sed -ri 's/^\s*dictcheck\s*=\s*0\b/# dictcheck = 0/' {} +
#   args:
#     executable: /bin/bash

# - name: "CIS 4.4.3.2.6 - Remove dictcheck=0 from pam_pwquality.so lines in PAM files"
#   ansible.builtin.lineinfile:
#     path: "/etc/authselect/custom/custom-profile/{{ item }}"
#     regexp: '^(.*pam_pwquality\.so.*)\s+dictcheck\s*=\s*0(.*)$'
#     line: '\1\2'
#     backrefs: yes
#     state: present
#   loop:
#     - system-auth
#     - password-auth

# - name: "CIS 4.4.3.2.6 - Apply authselect changes"
#   ansible.builtin.command: authselect apply-changes
#   changed_when: true

# - name: "CIS 4.4.3.2.7 - Ensure enforce_for_root is enabled in pwquality"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwquality.conf.d/50-pwroot.conf
#     create: true
#     block: |
#       enforce_for_root
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.3 - Configure pam_pwhistory defaults in /etc/security/pwhistory.conf"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwhistory.conf
#     create: true
#     block: |
#       remember = 5
#       enforce_for_root
#       retry = 3
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.3.1 - Ensure password history remember is set to 24"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwhistory.conf
#     create: true
#     block: |
#       remember = 24
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.3.2 - Ensure password history is enforced for the root user"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwhistory.conf
#     create: true
#     block: |
#       enforce_for_root
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.3 - Enforce password history and root enforcement"
#   ansible.builtin.blockinfile:
#     path: /etc/security/pwhistory.conf
#     create: true
#     block: |
#       remember = 24
#       enforce_for_root
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.4.3.3.3 - Ensure pam_pwhistory includes use_authtok"
#   block:
#     - name: "Determine active authselect custom profile name"
#       command: awk 'NR==1 {print $1}' /etc/authselect/authselect.conf
#       register: authselect_profile

#     - name: "Set path to custom profile"
#       set_fact:
#         authselect_custom_path: "/etc/authselect/{{ authselect_profile.stdout }}"

#     - name: "Ensure pam_pwhistory.so includes use_authtok in system-auth and password-auth"
#       lineinfile:
#         path: "{{ authselect_custom_path }}/{{ item }}"
#         regexp: '^\s*password\s+(requisite|required|sufficient)\s+pam_pwhistory\.so(?!.*use_authtok)'
#         line: '\g<0> use_authtok'
#         backrefs: yes
#       loop:
#         - system-auth
#         - password-auth

#     - name: "Apply authselect changes"
#       command: authselect apply-changes

# - name: "CIS 4.4.3.4.1 - Remove 'nullok' from pam_unix.so lines"
#   block:

#     - name: "Get active custom authselect profile"
#       command: awk 'NR==1 {print $1}' /etc/authselect/authselect.conf
#       register: authselect_profile

#     - name: "Fail if not using a custom profile"
#       fail:
#         msg: "A custom authselect profile is required to edit PAM templates."
#       when: authselect_profile.stdout is not regex("^custom/")

#     - name: "Set custom profile path"
#       set_fact:
#         authselect_custom_path: "/etc/authselect/{{ authselect_profile.stdout }}"

#     - name: "Remove 'nullok' from pam_unix.so lines"
#       replace:
#         path: "{{ authselect_custom_path }}/{{ item }}"
#         regexp: '(^\s*(auth|password)\s+(requisite|required|sufficient)\s+pam_unix\.so\s+[^#\n]*)\bnullok\b\s*'
#         replace: '\1'
#         backup: yes
#       loop:
#         - system-auth
#         - password-auth

#     - name: "Apply authselect changes"
#       command: authselect apply-changes


# - name: "CIS 4.4.3.4.2 - Ensure pam_unix.so does not include remember=n"
#   block:

#     - name: "Check active Authselect profile"
#       command: awk 'NR==1 {print $1}' /etc/authselect/authselect.conf
#       register: authselect_profile

#     - name: "Fail if not using a custom authselect profile"
#       fail:
#         msg: "A custom Authselect profile is required to safely modify pam_unix.so configuration."
#       when: authselect_profile.stdout is not regex("^custom/")

#     - name: "Set custom profile path"
#       set_fact:
#         authselect_custom_path: "/etc/authselect/{{ authselect_profile.stdout }}"

#     - name: "Remove 'remember=n' from pam_unix.so lines in system-auth and password-auth"
#       replace:
#         path: "{{ authselect_custom_path }}/{{ item }}"
#         regexp: '(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+[^#\n]*?)\bremember=\d+\b(.*$)'
#         replace: '\1\2'
#         backup: yes
#       loop:
#         - system-auth
#         - password-auth

#     - name: "Apply Authselect changes"
#       command: authselect apply-changes

# - name: "CIS 4.4.3.4.3 - Ensure pam_unix.so includes a strong password hashing algorithm (sha512 or yescrypt)"
#   block:

#     - name: "Get active authselect profile"
#       command: awk 'NR==1 {print $1}' /etc/authselect/authselect.conf
#       register: authselect_profile

#     - name: "Fail if not using a custom profile"
#       fail:
#         msg: "A custom authselect profile is required to modify PAM templates."
#       when: authselect_profile.stdout is not regex("^custom/")

#     - name: "Set PAM profile template path"
#       set_fact:
#         pam_profile_path: "/etc/authselect/{{ authselect_profile.stdout }}"

#     - name: "Ensure strong hashing algorithm is present in pam_unix.so"
#       block:
#         - name: "Check for strong hash (sha512 or yescrypt)"
#           shell: |
#             grep -P '^\h*password\h+(requisite|required|sufficient)\h+pam_unix\.so\h+.*\b(sha512|yescrypt)\b' {{ pam_profile_path }}/{{ item }} && echo "present"
#           args:
#             warn: false
#           register: hash_check
#           changed_when: false
#           failed_when: false
#           loop:
#             - password-auth
#             - system-auth
#           loop_control:
#             label: "{{ item }}"

#         - name: "Fix weak or missing password hashing algorithms"
#           ansible.builtin.replace:
#             path: "{{ pam_profile_path }}/{{ item.0 }}"
#             regexp: '(^\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)(md5|bigcrypt|sha256|blowfish)(\s*.*)$'
#             replace: '\1 sha512\4'
#             backup: yes
#           when: item.1.stdout is defined and item.1.stdout != "present"
#           loop: "{{ ['password-auth', 'system-auth'] | zip(hash_check.results) | list }}"
#           loop_control:
#             label: "{{ item.0 }}"


#     - name: "Apply authselect changes"
#       command: authselect apply-changes

# - name: "Read active authselect profile name"
#   command: awk 'NR==1{print $1}' /etc/authselect/authselect.conf
#   register: authselect_profile_name

# - name: "Set correct pam_profile_path"
#   set_fact:
#     pam_profile_path: >-
#       {{
#         '/etc/authselect/' + authselect_profile_name.stdout
#         if authselect_profile_name.stdout is match('^custom/')
#         else '/usr/share/authselect/default/' + authselect_profile_name.stdout
#       }}

# - name: "Ensure pam_unix.so includes use_authtok"
#   lineinfile:
#     path: "{{ pam_profile_path }}/{{ item }}"
#     regexp: '^(?P<indent>\s*password\s+(requisite|required|sufficient)\s+pam_unix\.so\s+.*)(?<!use_authtok)(?P<rest>\s*)$'
#     line: '\g<indent> use_authtok\g<rest>'
#     backrefs: yes
#     state: present
#   loop:
#     - password-auth
#     - system-auth
#   when: pam_profile_path is defined

# - name: "Apply authselect changes"
#   command: authselect apply-changes

# - name: "Ensure strong password hashing algorithm is configured (CIS 4.5.1.1)"
#   block:
#     - name: "Ensure 'crypt_style = sha512' is set in /etc/libuser.conf"
#       lineinfile:
#         path: /etc/libuser.conf
#         regexp: '^\s*crypt_style\s*='
#         line: 'crypt_style = sha512'
#         create: yes
#         state: present
#         backup: yes

#     - name: "Ensure 'ENCRYPT_METHOD SHA512' is set in /etc/login.defs"
#       lineinfile:
#         path: /etc/login.defs
#         regexp: '^\s*ENCRYPT_METHOD\s+'
#         line: 'ENCRYPT_METHOD SHA512'
#         create: yes
#         state: present
#         backup: yes

#     - name: "Force password reset for all non-system users (optional, recommended)"
#       shell: |
#         awk -F: '($3 >= {{ uid_min | default(1000) }} && $1 != "nfsnobody") {print $1}' /etc/passwd | xargs -n 1 chage -d 0
#       args:
#         warn: false
#       when: force_password_reset | default(false)

#   tags:
#     - CIS
#     - level1
#     - password
#     - hashing

# - name: "Ensure password expiration is 365 days or less (CIS 4.5.1.2)"
#   block:

#     - name: "Set PASS_MAX_DAYS to 365 in /etc/login.defs"
#       lineinfile:
#         path: /etc/login.defs
#         regexp: '^\\s*PASS_MAX_DAYS\\s+'
#         line: 'PASS_MAX_DAYS   365'
#         state: present
#         create: yes
#         backup: yes

#     - name: "Get all local users with password set (non-locked accounts)"
#       shell: "awk -F: '($2 !~ /^[!*]/) { print $1 }' /etc/shadow"
#       register: users_with_password
#       changed_when: false

#     - name: "Set password max days to 365 for each user"
#       command: chage --maxdays 365 {{ item }}
#       loop: "{{ users_with_password.stdout_lines }}"
#       when: users_with_password.stdout_lines | length > 0

#   tags:
#     - CIS
#     - level1
#     - password
#     - expiration

# - name: "Ensure password expiration warning days is 7 or more (CIS 4.5.1.3)"
#   block:

#     - name: "Set PASS_WARN_AGE to 7 in /etc/login.defs"
#       lineinfile:
#         path: /etc/login.defs
#         regexp: '^\\s*PASS_WARN_AGE\\s+'
#         line: 'PASS_WARN_AGE   7'
#         state: present
#         create: yes
#         backup: yes

#     - name: "Get users with valid passwords"
#       shell: "awk -F: '$2 !~ /^[!*]/ { print $1 }' /etc/shadow"
#       register: users_with_passwords
#       changed_when: false


#     - name: "Set password warning days to 7 for each user"
#       command: chage --warndays 7 {{ item }}
#       loop: "{{ users_with_passwords.stdout_lines }}"
#       when: users_with_passwords.stdout_lines | length > 0

#   tags:
#     - CIS
#     - password-policy
#     - login-defs
#     - warn-age

# - name: "CIS 4.5.1.4 - Set default password inactivity to 30 days"
#   command: useradd -D -f 30

# - name: "Get users with valid passwords"
#   shell: "awk -F: '$2 !~ /^[!*]/ { print $1 }' /etc/shadow"
#   register: users_with_passwords
#   changed_when: false

# - name: "Set password inactivity for users with valid passwords"
#   command: "chage --inactive 30 {{ item }}"
#   loop: "{{ users_with_passwords.stdout_lines }}"
#   when: users_with_passwords.stdout_lines | length > 0

# - name: "CIS 4.5.1.5 - Get users with valid passwords"
#   shell: "awk -F: '$2 !~ /^[!*]/ { print $1 }' /etc/shadow"
#   register: valid_users
#   changed_when: false

# - name: "Check if any user has future password change date"
#   shell: |
#     l_change=$(date -d "$(chage --list {{ item }} | grep '^Last password change' | cut -d: -f2 | sed 's/^ *//')" +%s 2>/dev/null || echo 0)
#     if [ "$l_change" -gt "$(date +%s)" ]; then
#       echo "{{ item }}"
#     fi
#   loop: "{{ valid_users.stdout_lines }}"
#   register: users_with_future_change
#   changed_when: false
#   failed_when: false

# - name: "Set password as expired for users with future password change date"
#   command: chage -d 0 {{ item.item }}
#   loop: "{{ users_with_future_change.results | selectattr('stdout', '!=', '') | list }}"
#   when: item.stdout != ''

# - name: "CIS 4.5.2.1 - Check if root's primary group is GID 0"
#   ansible.builtin.command: >
#     awk -F: '$1=="root"{print $4}' /etc/passwd
#   register: root_gid

# - name: "CIS 4.5.2.1 - Fail if root's GID is not 0"
#   ansible.builtin.fail:
#     msg: "Root's primary group ID is not 0"
#   when: root_gid.stdout != "0"

# - name: "CIS 4.5.2.1 - Set root user's primary group to GID 0"
#   ansible.builtin.command: usermod -g 0 root
#   when: root_gid.stdout != "0"

# - name: "CIS 4.5.2.2 - Ensure root user umask is set to 0027 in /root/.bash_profile"
#   ansible.builtin.lineinfile:
#     path: /root/.bash_profile
#     regexp: '^\s*umask\s+'
#     line: 'umask 0027'
#     state: present
#     create: yes
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.5.2.2 - Ensure root user umask is set to 0027 in /root/.bashrc"
#   ansible.builtin.lineinfile:
#     path: /root/.bashrc
#     regexp: '^\s*umask\s+'
#     line: 'umask 0027'
#     state: present
#     create: yes
#     owner: root
#     group: root
#     mode: '0644'

# - name: "CIS 4.5.2.3 - Get UID_MIN from /etc/login.defs"
#   command: awk '/^UID_MIN/ {print $2}' /etc/login.defs
#   register: uid_min
#   changed_when: false

# - name: "CIS 4.5.2.3 - Get system accounts with login shells"
#   shell: |
#     awk -F: -v min_uid="{{ uid_min.stdout }}" '($1!~/^(root|halt|sync|shutdown|nfsnobody)$/ && ($3<min_uid || $3 == 65534) && $7 !~ /nologin/) { print $1 }' /etc/passwd
#   register: login_shell_accounts
#   changed_when: false

# - name: "CIS 4.5.2.3 - Set shell to /sbin/nologin for system accounts"
#   command: usermod -s /sbin/nologin {{ item }}
#   loop: "{{ login_shell_accounts.stdout_lines }}"
#   when: login_shell_accounts.stdout_lines | length > 0

# - name: "CIS 4.5.2.3 - Get accounts with nologin but not locked"
#   shell: |
#     awk -F: '/nologin/ {print $1}' /etc/passwd | xargs -r -I '{}' passwd -S '{}' | awk '($2!="L" && $2!="LK") {print $1}'
#   register: not_locked_nologin_accounts
#   changed_when: false

# - name: "CIS 4.5.2.3 - Lock accounts with nologin shell that are not locked"
#   command: usermod -L {{ item }}
#   loop: "{{ not_locked_nologin_accounts.stdout_lines }}"
#   when: not_locked_nologin_accounts.stdout_lines | length > 0

# - name: "CIS 4.5.3.1 - Ensure /nologin is not listed in /etc/shells"
#   lineinfile:
#     path: /etc/shells
#     regexp: '^(/usr)?/sbin/nologin$'
#     state: absent
#   tags:
#     - CIS_4.5.3.1

# - name: "CIS 4.5.3.2 - Ensure shell timeout TMOUT is configured (900 seconds, readonly, exported)"
#   block:
#     - name: "Create TMOUT configuration script in /etc/profile.d"
#       copy:
#         dest: /etc/profile.d/cis_tmout.sh
#         content: |
#           #!/bin/bash
#           TMOUT=900
#           readonly TMOUT
#           export TMOUT
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Ensure /etc/profile.d/cis_tmout.sh is executable"
#       file:
#         path: /etc/profile.d/cis_tmout.sh
#         mode: '0755'
#         owner: root
#         group: root
#         state: file
#   tags:
#     - CIS_4.5.3.2

# - name: "CIS 4.5.3.3 - Ensure default user umask is configured (027 or stricter)"
#   block:
#     - name: "Create system-wide umask configuration file"
#       copy:
#         dest: /etc/profile.d/cis_umask.sh
#         content: |
#           #!/bin/bash
#           umask 027
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Ensure pam_umask is configured in /etc/pam.d/postlogin"
#       lineinfile:
#         path: /etc/pam.d/postlogin
#         regexp: '^session\s+optional\s+pam_umask.so'
#         line: 'session optional pam_umask.so umask=027'
#         state: present
#         create: yes
#         insertafter: EOF
#         backup: yes

#     - name: "Ensure UMASK is configured in /etc/login.defs"
#       lineinfile:
#         path: /etc/login.defs
#         regexp: '^UMASK'
#         line: 'UMASK 027'
#         state: present
#         create: yes
#         backup: yes
#   tags:
#     - CIS_4.5.3.3


# - name: "CIS 5.1.1.2 - Ensure rsyslog service is enabled"
#   block:
#     - name: "Check if rsyslog is installed"
#       command: rpm -q rsyslog
#       register: rsyslog_installed
#       ignore_errors: yes

#     - name: "Enable and start rsyslog service if installed"
#       when: rsyslog_installed.rc == 0
#       service:
#         name: rsyslog
#         enabled: yes
#         state: started
#   tags:
#     - CIS_5.1.1.2

# - name: "CIS 5.1.1.3 - Ensure journald forwards logs to rsyslog"
#   block:

#     - name: "Create journald override directory if it doesn't exist"
#       file:
#         path: /etc/systemd/journald.conf.d
#         state: directory
#         owner: root
#         group: root
#         mode: '0755'

#     - name: "Ensure journald ForwardToSyslog is set to yes"
#       copy:
#         dest: /etc/systemd/journald.conf.d/50-forwardtosyslog.conf
#         content: |
#           [Journal]
#           ForwardToSyslog=yes
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Restart systemd-journald to apply configuration"
#       systemd:
#         name: systemd-journald
#         state: restarted
#         enabled: yes

#   tags:
#     - CIS_5.1.1.3

# - name: "CIS 5.1.1.4 - Ensure rsyslog default file permissions are configured"
#   block:

#     - name: "Ensure rsyslog.d directory exists"
#       file:
#         path: /etc/rsyslog.d
#         state: directory
#         mode: '0755'
#         owner: root
#         group: root

#     - name: "Set FileCreateMode to 0640 in rsyslog configuration"
#       copy:
#         dest: /etc/rsyslog.d/50-filecreatemode.conf
#         content: |
#           $FileCreateMode 0640
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Restart rsyslog service"
#       systemd:
#         name: rsyslog
#         state: restarted
#         enabled: yes

#   tags:
#     - CIS_5.1.1.4

# - name: "CIS 5.1.1.5 - Ensure logging is configured"
#   block:

#     - name: "Ensure rsyslog.d directory exists"
#       file:
#         path: /etc/rsyslog.d
#         state: directory
#         mode: '0755'
#         owner: root
#         group: root

#     - name: "Configure default logging rules"
#       copy:
#         dest: /etc/rsyslog.d/50-default-logging.conf
#         content: |
#           *.emerg                                   :omusrmsg:*
#           auth,authpriv.*                           /var/log/secure
#           mail.*                                    -/var/log/mail
#           mail.info                                 -/var/log/mail.info
#           mail.warning                              -/var/log/mail.warn
#           mail.err                                  /var/log/mail.err
#           cron.*                                    /var/log/cron
#           *.=warning;*.=err                         -/var/log/warn
#           *.crit                                    /var/log/warn
#           *.*;mail.none;news.none                   -/var/log/messages
#           local0,local1.*                           -/var/log/localmessages
#           local2,local3.*                           -/var/log/localmessages
#           local4,local5.*                           -/var/log/localmessages
#           local6,local7.*                           -/var/log/localmessages
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Restart rsyslog to apply logging configuration"
#       systemd:
#         name: rsyslog
#         state: restarted
#         enabled: yes

#   tags:
#     - CIS_5.1.1.5

# - name: "CIS 5.1.1.6 - Ensure rsyslog sends logs to remote host"
#   block:

#     - name: "Ensure rsyslog.d directory exists"
#       file:
#         path: /etc/rsyslog.d
#         state: directory
#         mode: '0755'
#         owner: root
#         group: root

#     - name: "Configure rsyslog to forward logs to remote host"
#       copy:
#         dest: /etc/rsyslog.d/60-remote-logging.conf
#         content: |
#           *.* action(
#             type="omfwd"
#             target="192.168.2.100"
#             port="514"
#             protocol="tcp"
#             action.resumeRetryCount="100"
#             queue.type="LinkedList"
#             queue.size="1000"
#           )
#         owner: root
#         group: root
#         mode: '0644'

#     - name: "Restart rsyslog to apply remote logging configuration"
#       systemd:
#         name: rsyslog
#         state: restarted
#         enabled: yes

#   tags:
#     - CIS_5.1.1.6

# - name: "CIS 5.1.1.7 - Ensure rsyslog is not configured to receive remote logs"
#   block:

#     - name: "Remove old format rsyslog server directives if present"
#       lineinfile:
#         path: "{{ item }}"
#         regexp: '^\s*\$ModLoad\s+imtcp'
#         state: absent
#       with_fileglob:
#         - /etc/rsyslog.conf
#         - /etc/rsyslog.d/*.conf
#       ignore_errors: true

#     - name: "Remove old format $InputTCPServerRun directive"
#       lineinfile:
#         path: "{{ item }}"
#         regexp: '^\s*\$InputTCPServerRun'
#         state: absent
#       with_fileglob:
#         - /etc/rsyslog.conf
#         - /etc/rsyslog.d/*.conf
#       ignore_errors: true

#     - name: "Remove new format rsyslog TCP input module line"
#       lineinfile:
#         path: "{{ item }}"
#         regexp: '^\s*module\(load="imtcp"\)'
#         state: absent
#       with_fileglob:
#         - /etc/rsyslog.conf
#         - /etc/rsyslog.d/*.conf
#       ignore_errors: true

#     - name: "Remove new format rsyslog input TCP port line"
#       lineinfile:
#         path: "{{ item }}"
#         regexp: '^\s*input\(type="imtcp"\s+port="514"\)'
#         state: absent
#       with_fileglob:
#         - /etc/rsyslog.conf
#         - /etc/rsyslog.d/*.conf
#       ignore_errors: true

#     - name: "Restart rsyslog after removing remote listener configs"
#       systemd:
#         name: rsyslog
#         state: restarted
#         enabled: yes

#   tags:
#     - CIS_5.1.1.7

# - name: "CIS 5.1.2.1.1 - Ensure systemd-journal-remote is installed"
#   block:
#     - name: "Check if systemd-journal-remote is already installed"
#       command: rpm -q systemd-journal-remote
#       register: journal_remote_check
#       ignore_errors: yes
#       changed_when: false

#     - name: "Log message if systemd-journal-remote is not installed"
#       debug:
#         msg: "systemd-journal-remote is NOT installed on the system."
#       when: journal_remote_check.rc != 0

#     - name: "Log message if systemd-journal-remote is installed"
#       debug:
#         msg: "systemd-journal-remote is installed."
#       when: journal_remote_check.rc == 0

# - name: "CIS 5.1.2.1.2 - Ensure systemd-journal-remote is configured"
#   block:

#     - name: "Check if journal-upload.conf exists"
#       stat:
#         path: /etc/systemd/journal-upload.conf
#       register: journal_upload_conf

#     - name: "Read journal-upload.conf if it exists"
#       slurp:
#         src: /etc/systemd/journal-upload.conf
#       register: journal_upload_content
#       when: journal_upload_conf.stat.exists

#     - name: "Decode and parse journal-upload.conf"
#       set_fact:
#         journal_upload_lines: "{{ journal_upload_content['content'] | b64decode | splitlines }}"
#       when: journal_upload_conf.stat.exists

#     - name: "Show configuration values"
#       debug:
#         msg: "{{ journal_upload_lines | select('match', '^\\s*(URL|ServerKeyFile|ServerCertificateFile|TrustedCertificateFile)=') | list }}"
#       when: journal_upload_conf.stat.exists

#     - name: "Warn if journal-upload.conf is missing"
#       debug:
#         msg: "systemd-journal-remote configuration file not found at /etc/systemd/journal-upload.conf"
#       when: not journal_upload_conf.stat.exists

# - name: "Restart systemd-journal-upload"
#   systemd:
#     name: systemd-journal-upload
#     state: restarted
#     enabled: yes
#   when: journal_upload_conf.stat.exists

# - name: "CIS 5.1.2.1.3 - Ensure systemd-journal-upload.service is enabled"
#   block:

#     - name: "Check if systemd-journal-upload.service unit file exists"
#       stat:
#         path: /usr/lib/systemd/system/systemd-journal-upload.service
#       register: journal_upload_service_file

#     - name: "Enable and start systemd-journal-upload.service"
#       systemd:
#         name: systemd-journal-upload.service
#         enabled: yes
#         state: started
#       when: journal_upload_service_file.stat.exists

#     - name: "Warn if systemd-journal-upload.service is not installed"
#       debug:
#         msg: "systemd-journal-upload.service not found. Skipping enable step."
#       when: not journal_upload_service_file.stat.exists

# - name: "CIS 5.1.2.1.4 - Ensure journald is not configured to receive remote logs"
#   block:

#     - name: "Check if systemd-journal-remote.socket unit exists"
#       stat:
#         path: /usr/lib/systemd/system/systemd-journal-remote.socket
#       register: journal_socket

#     - name: "Mask systemd-journal-remote.socket if present"
#       systemd:
#         name: systemd-journal-remote.socket
#         enabled: no
#         masked: yes
#         state: stopped
#       when: journal_socket.stat.exists

#     - name: "Warn if systemd-journal-remote.socket is not found"
#       debug:
#         msg: "systemd-journal-remote.socket not found. Nothing to mask."
#       when: not journal_socket.stat.exists

# - name: "CIS 5.1.2.2 - Ensure journald service is enabled (should be 'static')"
#   block:

#     - name: "Check status of systemd-journald service"
#       command: systemctl is-enabled systemd-journald.service
#       register: journald_status
#       changed_when: false
#       failed_when: journald_status.rc != 0 and journald_status.stdout != "static"

#     - name: "Warn if journald service is not static"
#       debug:
#         msg: "systemd-journald service is in unexpected state: {{ journald_status.stdout }}"
#       when: journald_status.stdout != "static"

# - name: "CIS 5.1.2.3 - Ensure journald is configured to compress large log files"
#   block:

#     - name: "Check if journald is configured to compress logs"
#       command: grep '^\s*Compress' /etc/systemd/journald.conf
#       register: compress_status
#       changed_when: false
#       failed_when: false

#     - name: "Warn if journald log compression is not enabled"
#       debug:
#         msg: "journald is not configured to compress large log files. Expected 'Compress=yes'. Got: {{ compress_status.stdout }}"
#       when: compress_status.stdout != 'Compress=yes'

#     - name: "Ensure journald log compression is enabled"
#       lineinfile:
#         path: /etc/systemd/journald.conf
#         regexp: '^#?\s*Compress='
#         line: 'Compress=yes'
#         create: yes
#         state: present

#     - name: "Restart journald service"
#       systemd:
#         name: systemd-journald
#         state: restarted
#       when: compress_status.stdout != 'Compress=yes'

# - name: Ensure journald is configured to write logs to persistent disk
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?Storage='
#     line: 'Storage=persistent'
#     create: yes
#     state: present
#   #notify: Restart journald

# - name: Restart journald
#   become: true
#   systemd:
#     name: systemd-journald
#     state: restarted

# - name: Ensure ForwardToSyslog is not set in journald.conf
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?ForwardToSyslog='
#     state: absent

# - name: Restart journald to apply ForwardToSyslog removal
#   become: true
#   systemd:
#     name: systemd-journald
#     state: restarted
#     daemon_reload: yes

# - name: Set journald SystemMaxUse
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?SystemMaxUse='
#     line: 'SystemMaxUse=500M'
#     create: yes

# - name: Set journald SystemKeepFree
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?SystemKeepFree='
#     line: 'SystemKeepFree=100M'
#     create: yes

# - name: Set journald RuntimeMaxUse
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?RuntimeMaxUse='
#     line: 'RuntimeMaxUse=200M'
#     create: yes

# - name: Set journald RuntimeKeepFree
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?RuntimeKeepFree='
#     line: 'RuntimeKeepFree=50M'
#     create: yes

# - name: Set journald MaxFileSec
#   become: true
#   lineinfile:
#     path: /etc/systemd/journald.conf
#     regexp: '^#?MaxFileSec='
#     line: 'MaxFileSec=1week'
#     create: yes

# - name: Restart journald to apply log rotation settings
#   become: true
#   systemd:
#     name: systemd-journald
#     state: restarted
#     daemon_reload: yes

# - name: Check if logrotate is already installed
#   become: true
#   command: rpm -q logrotate
#   register: logrotate_check
#   ignore_errors: yes

# - name: Install logrotate if not present
#   become: true
#   yum:
#     name: logrotate
#     state: present
#   when: logrotate_check.rc != 0


# - name: Configure global log rotation policy in /etc/logrotate.conf
#   become: true
#   copy:
#     dest: /etc/logrotate.conf
#     content: |
#       weekly
#       rotate 4
#       create
#       dateext
#       compress
#       include /etc/logrotate.d
#       maxage 30
#       su root root
#       notifempty
#       missingok
#     owner: root
#     group: root
#     mode: '0644'

# - name: Find all regular files under /var/log with improper permissions
#   become: true
#   find:
#     paths: /var/log
#     file_type: file
#     recurse: yes
#   register: log_files

# - name: Set secure permissions (640) for /var/log files
#   become: true
#   file:
#     path: "{{ item.path }}"
#     mode: '0640'
#   loop: "{{ log_files.files }}"
#   when: item.mode is defined and item.mode|int(base=8) > 640

# - name: Set owner to root for /var/log files
#   become: true
#   file:
#     path: "{{ item.path }}"
#     owner: root
#   loop: "{{ log_files.files }}"
#   when: item.uid != 0

# - name: Set group to root or adm for /var/log files if group is not acceptable
#   become: true
#   file:
#     path: "{{ item.path }}"
#     group: root
#   loop: "{{ log_files.files }}"
#   when: item.gid not in [0, 4]   # 0=root, 4=adm on most Linux systems

# - name: Install auditd with GPG check disabled
#   become: true
#   shell: dnf install -y --nogpgcheck audit
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.1.2 | Ensure auditing for processes that start prior to auditd is enabled"
#   become: true
#   command: grubby --update-kernel ALL --args 'audit=1'
#   register: audit_boot_flag
#   changed_when: "'audit=1' not in audit_boot_flag.stdout"


# - name: "CIS 5.2.1.2 | Check if audit=1 is already set in GRUB"
#   become: true
#   command: grubby --info=ALL
#   register: grub_audit_check

# - name: "CIS 5.2.1.2 | Ensure auditing for processes that start prior to auditd is enabled"
#   become: true
#   command: grubby --update-kernel ALL --args 'audit=1'
#   when: "'audit=1' not in grub_audit_check.stdout"

# - name: "CIS 5.2.1.3 | Set audit_backlog_limit=8192 if not already present"
#   become: true
#   command: grubby --update-kernel ALL --args 'audit_backlog_limit=8192'
#   register: backlog_limit_result
#   changed_when: "'audit_backlog_limit=8192' not in backlog_limit_result.stdout"

# - name: "CIS 5.2.1.3 | Check if audit_backlog_limit is already set"
#   become: true
#   command: grubby --info=ALL
#   register: grub_audit_backlog

# - name: "CIS 5.2.1.3 | Set audit_backlog_limit=8192 if not already present"
#   become: true
#   command: grubby --update-kernel ALL --args 'audit_backlog_limit=8192'
#   when: "'audit_backlog_limit=' not in grub_audit_backlog.stdout or 'audit_backlog_limit=8192' not in grub_audit_backlog.stdout"

# - name: "CIS 5.2.1.4 | Ensure auditd service is enabled and running"
#   become: true
#   systemd:
#     name: auditd
#     enabled: true
#     state: started

# - name: "CIS 5.2.2.1 | Ensure audit log max file size is set (e.g., 100 MB)"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*max_log_file\s*='
#     line: 'max_log_file = 100'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.2.2 | Ensure audit logs are not automatically deleted (keep_logs)"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*max_log_file_action\s*='
#     line: 'max_log_file_action = keep_logs'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.2.3 | Ensure disk_full_action is set to halt"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*disk_full_action\s*='
#     line: 'disk_full_action = halt'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.2.3 | Ensure disk_error_action is set to syslog"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*disk_error_action\s*='
#     line: 'disk_error_action = syslog'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.2.4 | Ensure space_left_action is set to email"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*space_left_action\s*='
#     line: 'space_left_action = email'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.2.4 | Ensure admin_space_left_action is set to single"
#   become: true
#   lineinfile:
#     path: /etc/audit/auditd.conf
#     regexp: '^#?\s*admin_space_left_action\s*='
#     line: 'admin_space_left_action = single'
#     create: yes
#     backrefs: yes

# - name: "CIS 5.2.3.1 | Ensure audit rule for /etc/sudoers is configured"
#   become: true
#   copy:
#     dest: /etc/audit/rules.d/50-scope.rules
#     content: |
#       -w /etc/sudoers -p wa -k scope
#       -w /etc/sudoers.d -p wa -k scope
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.1 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.1 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.1 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.2 | Ensure audit rules for user emulation (sudo-like actions) are configured"
#   become: true
#   copy:
#     dest: /etc/audit/rules.d/50-user_emulation.rules
#     content: |
#       -a always,exit -F arch=b64 -C euid!=uid -F auid!=unset -S execve -k user_emulation
#       -a always,exit -F arch=b32 -C euid!=uid -F auid!=unset -S execve -k user_emulation
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.2 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.2 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.2 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.3 | Get sudo log file path from sudoers config"
#   become: true
#   shell: |
#     grep -r 'logfile=' /etc/sudoers /etc/sudoers.d 2>/dev/null | \
#     sed -e 's/.*logfile=//;s/,.*//' -e 's/"//g' | head -n1
#   register: sudo_log_file
#   changed_when: false

# - name: "CIS 5.2.3.3 | Fail if no sudo log file is configured"
#   fail:
#     msg: "No sudo log file is configured via Defaults logfile= in /etc/sudoers or /etc/sudoers.d"
#   when: sudo_log_file.stdout == ""

# - name: "CIS 5.2.3.3 | Configure audit rule to monitor sudo log file"
#   become: true
#   copy:
#     dest: /etc/audit/rules.d/50-sudo_log_file.rules
#     content: |
#       -w {{ sudo_log_file.stdout }} -p wa -k sudo_log_file
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.3 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.3 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.3 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.4 | Configure audit rules for date and time changes"
#   become: true
#   copy:
#     dest: /etc/audit/rules.d/50-time-change.rules
#     content: |
#       -a always,exit -F arch=b64 -S adjtimex,settimeofday,clock_settime -k time-change
#       -a always,exit -F arch=b32 -S adjtimex,settimeofday,clock_settime,stime -k time-change
#       -w /etc/localtime -p wa -k time-change
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.4 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.4 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.4 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.5 | Configure audit rules for network environment changes"
#   become: true
#   copy:
#     dest: /etc/audit/rules.d/50-system_local.rules
#     content: |
#       -a always,exit -F arch=b64 -S sethostname,setdomainname -k system-locale
#       -a always,exit -F arch=b32 -S sethostname,setdomainname -k system-locale
#       -w /etc/issue -p wa -k system-locale
#       -w /etc/issue.net -p wa -k system-locale
#       -w /etc/hosts -p wa -k system-locale
#       -w /etc/sysconfig/network -p wa -k system-locale
#       -w /etc/sysconfig/network-scripts/ -p wa -k system-locale
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.5 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.5 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.5 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.6 | Find privileged executables and generate audit rules"
#   become: true
#   shell: |
#     UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
#     AUDIT_RULE_FILE="/etc/audit/rules.d/50-privileged.rules"
#     > "${AUDIT_RULE_FILE}"
#     {
#       find / -xdev -perm /6000 -type f 2>/dev/null
#       find /boot/efi -xdev -perm /6000 -type f 2>/dev/null
#     } | sort -u | while read -r file; do
#       echo "-a always,exit -F path=${file} -F perm=x -F auid>=${UID_MIN} -F auid!=unset -k privileged"
#     done >> "${AUDIT_RULE_FILE}"
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.3.6 | Set proper permissions on 50-privileged.rules"
#   become: true
#   file:
#     path: /etc/audit/rules.d/50-privileged.rules
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.6 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.6 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.6 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.7 | Create audit rules for unsuccessful file access attempts"
#   become: true
#   shell: |
#     UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
#     AUDIT_RULE_FILE="/etc/audit/rules.d/50-access.rules"
#     > "${AUDIT_RULE_FILE}"
#     echo "-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=EACCES -F auid>=$UID_MIN -F auid!=unset -k access" >> "${AUDIT_RULE_FILE}"
#     echo "-a always,exit -F arch=b64 -S creat,open,openat,truncate,ftruncate -F exit=EPERM  -F auid>=$UID_MIN -F auid!=unset -k access" >> "${AUDIT_RULE_FILE}"
#     echo "-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=EACCES -F auid>=$UID_MIN -F auid!=unset -k access" >> "${AUDIT_RULE_FILE}"
#     echo "-a always,exit -F arch=b32 -S creat,open,openat,truncate,ftruncate -F exit=EPERM  -F auid>=$UID_MIN -F auid!=unset -k access" >> "${AUDIT_RULE_FILE}"
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.3.7 | Set proper permissions on 50-access.rules"
#   become: true
#   file:
#     path: /etc/audit/rules.d/50-access.rules
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.7 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.7 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.7 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.8 | Create audit rules for user/group modification files"
#   become: true
#   shell: |
#     AUDIT_RULE_FILE="/etc/audit/rules.d/50-identity.rules"
#     > "${AUDIT_RULE_FILE}"
#     echo "-w /etc/group -p wa -k identity" >> "${AUDIT_RULE_FILE}"
#     echo "-w /etc/passwd -p wa -k identity" >> "${AUDIT_RULE_FILE}"
#     echo "-w /etc/gshadow -p wa -k identity" >> "${AUDIT_RULE_FILE}"
#     echo "-w /etc/shadow -p wa -k identity" >> "${AUDIT_RULE_FILE}"
#     echo "-w /etc/security/opasswd -p wa -k identity" >> "${AUDIT_RULE_FILE}"
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.3.8 | Set proper permissions on 50-identity.rules"
#   become: true
#   file:
#     path: /etc/audit/rules.d/50-identity.rules
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.8 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.8 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.8 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.9 | Create audit rules for permission modification events"
#   become: true
#   shell: |
#     UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
#     AUDIT_RULE_FILE="/etc/audit/rules.d/50-perm_mod.rules"
#     > "${AUDIT_RULE_FILE}"
#     if [ -n "$UID_MIN" ]; then
#       echo "-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b64 -S chown,fchown,lchown,fchownat -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b64 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b32 -S chown,fchown,lchown,fchownat -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b32 -S setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F auid>=$UID_MIN -F auid!=unset -F key=perm_mod" >> "${AUDIT_RULE_FILE}"
#     else
#       echo "ERROR: UID_MIN not found"
#       exit 1
#     fi
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.3.9 | Set permissions on 50-perm_mod.rules"
#   become: true
#   file:
#     path: /etc/audit/rules.d/50-perm_mod.rules
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.9 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.9 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.9 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

# - name: "CIS 5.2.3.10 | Create audit rules for successful file system mounts"
#   become: true
#   shell: |
#     UID_MIN=$(awk '/^\s*UID_MIN/{print $2}' /etc/login.defs)
#     AUDIT_RULE_FILE="/etc/audit/rules.d/50-mounts.rules"
#     > "${AUDIT_RULE_FILE}"
#     if [ -n "$UID_MIN" ]; then
#       echo "-a always,exit -F arch=b64 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts" >> "${AUDIT_RULE_FILE}"
#       echo "-a always,exit -F arch=b32 -S mount -F auid>=$UID_MIN -F auid!=unset -k mounts" >> "${AUDIT_RULE_FILE}"
#     else
#       echo "ERROR: UID_MIN not found"
#       exit 1
#     fi
#   args:
#     executable: /bin/bash

# - name: "CIS 5.2.3.10 | Set permissions on 50-mounts.rules"
#   become: true
#   file:
#     path: /etc/audit/rules.d/50-mounts.rules
#     owner: root
#     group: root
#     mode: '0640'

# - name: "CIS 5.2.3.10 | Load audit rules with augenrules"
#   become: true
#   command: augenrules --load

# - name: "CIS 5.2.3.10 | Check if audit system requires reboot to load rules (-e 2)"
#   become: true
#   shell: |
#     auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
#   register: auditd_reboot_check
#   changed_when: false

# - name: "CIS 5.2.3.10 | Warn if reboot is required to apply audit rule changes"
#   debug:
#     msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
#   when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"

- name: "CIS 5.2.3.11 | Create audit rules for session initiation files"
  become: true
  copy:
    dest: /etc/audit/rules.d/50-session.rules
    content: |
      -w /var/run/utmp -p wa -k session
      -w /var/log/wtmp -p wa -k session
      -w /var/log/btmp -p wa -k session
    owner: root
    group: root
    mode: '0640'

- name: "CIS 5.2.3.11 | Load audit rules with augenrules"
  become: true
  command: augenrules --load

- name: "CIS 5.2.3.11 | Check if audit system requires reboot to load rules (-e 2)"
  become: true
  shell: |
    auditctl -s | grep 'enabled' | grep -q '2' && echo "REBOOT_REQUIRED" || echo "OK"
  register: auditd_reboot_check
  changed_when: false

- name: "CIS 5.2.3.11 | Warn if reboot is required to apply audit rule changes"
  debug:
    msg: "Reboot required to fully apply audit rules (auditd is locked: -e 2)."
  when: auditd_reboot_check.stdout == "REBOOT_REQUIRED"
