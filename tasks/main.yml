- name: "1.1.1.1 | Ensure cramfs kernel module is not available (Automated)"
  block:

    - name: Check if cramfs kernel module is available
      command: modinfo cramfs
      register: cramfs_module
      ignore_errors: true
      changed_when: false

    - name: Unload cramfs kernel module if loaded
      ansible.builtin.shell: "modprobe -r cramfs"
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"
      ignore_errors: true

    - name: Blacklist cramfs module
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/cramfs.conf
        line: "blacklist cramfs"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"

    - name: Prevent cramfs module from loading
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/cramfs.conf
        line: "install cramfs /bin/false"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"

  rescue:
    - name: Fallback info if cramfs_module was not defined
      debug:
        msg: "cramfs module not available or 'modinfo' command failed â€” skipping tasks"

- name: "1.1.1.2 | Ensure freevxfs kernel module is not available (Automated)"
  block:

    - name: Check if freevxfs kernel module is available
      command: modinfo freevxfs
      register: freevxfs_module
      ignore_errors: true
      changed_when: false

    - name: Unload freevxfs kernel module if loaded
      ansible.builtin.shell: "modprobe -r freevxfs"
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"
      ignore_errors: true

    - name: Blacklist freevxfs module
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/freevxfs.conf
        line: "blacklist freevxfs"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

    - name: Prevent freevxfs module from loading
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/freevxfs.conf
        line: "install freevxfs /bin/false"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

  rescue:
    - name: Fallback info if freevxfs_module was not defined
      debug:
        msg: "freevxfs module not available or 'modinfo' command failed â€” skipping tasks"

# 1.1.1.3 Ensure hfs kernel module is not available
- name: Check if hfs kernel module is available
  command: modinfo hfs
  register: hfs_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

- name: Unload hfs kernel module if loaded
  command: modprobe -r hfs
  when: hfs_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

- name: Blacklist hfs module
  lineinfile:
    path: /etc/modprobe.d/hfs.conf
    line: "blacklist hfs"
    create: yes
  when: hfs_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

- name: Prevent hfs module from loading
  lineinfile:
    path: /etc/modprobe.d/hfs.conf
    line: "install hfs /bin/false"
    create: yes
  when: hfs_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

# 1.1.1.4 Ensure hfsplus kernel module is not available
- name: Check if hfsplus kernel module is available
  command: modinfo hfsplus
  register: hfsplus_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Unload hfsplus kernel module if loaded
  command: modprobe -r hfsplus
  when: hfsplus_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Blacklist hfsplus module
  lineinfile:
    path: /etc/modprobe.d/hfsplus.conf
    line: "blacklist hfsplus"
    create: yes
  when: hfsplus_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Prevent hfsplus module from loading
  lineinfile:
    path: /etc/modprobe.d/hfsplus.conf
    line: "install hfsplus /bin/false"
    create: yes
  when: hfsplus_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

# 1.1.1.5 Ensure jffs2 kernel module is not available
- name: Check if jffs2 kernel module is available
  command: modinfo jffs2
  register: jffs2_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Unload jffs2 kernel module if loaded
  command: modprobe -r jffs2
  when: jffs2_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Blacklist jffs2 module
  lineinfile:
    path: /etc/modprobe.d/jffs2.conf
    line: "blacklist jffs2"
    create: yes
  when: jffs2_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Prevent jffs2 module from loading
  lineinfile:
    path: /etc/modprobe.d/jffs2.conf
    line: "install jffs2 /bin/false"
    create: yes
  when: jffs2_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

# 1.1.1.6 Ensure squashfs kernel module is not available
- name: Check if squashfs kernel module is available
  command: modinfo squashfs
  register: squashfs_module
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Unload squashfs kernel module if loaded
  command: modprobe -r squashfs
  when: squashfs_module.rc == 0
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Blacklist squashfs module
  lineinfile:
    path: /etc/modprobe.d/squashfs.conf
    line: "blacklist squashfs"
    create: yes
  when: squashfs_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Prevent squashfs module from loading
  lineinfile:
    path: /etc/modprobe.d/squashfs.conf
    line: "install squashfs /bin/false"
    create: yes
  when: squashfs_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

# 1.1.1.7 Ensure udf kernel module is not available
- name: Check if udf kernel module is available
  command: modinfo udf
  register: udf_module
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Unload udf kernel module if loaded
  command: modprobe -r udf
  when: udf_module.rc == 0
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Blacklist udf module
  lineinfile:
    path: /etc/modprobe.d/udf.conf
    line: "blacklist udf"
    create: yes
  when: udf_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Prevent udf module from loading
  lineinfile:
    path: /etc/modprobe.d/udf.conf
    line: "install udf /bin/false"
    create: yes
  when: udf_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

# 1.1.1.8 Ensure usb-storage kernel module is not available
- name: Check if usb-storage kernel module is available
  command: modinfo usb-storage
  register: usb_storage_module
  ignore_errors: true
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Unload usb-storage kernel module if loaded
  command: modprobe -r usb-storage
  when: usb_storage_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Blacklist usb-storage kernel module
  lineinfile:
    path: /etc/modprobe.d/usb-storage.conf
    line: "blacklist usb-storage"
    create: yes
  when: usb_storage_module.rc == 0
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Prevent usb-storage kernel module from loading
  lineinfile:
    path: /etc/modprobe.d/usb-storage.conf
    line: "install usb-storage /bin/false"
    create: yes
  when: usb_storage_module.rc == 0
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

# 1.1.2.1.1 Ensure /tmp is a separate partition using tmpfs
- name: Ensure systemd tmp.mount is unmasked
  command: systemctl unmask tmp.mount
  ignore_errors: true
  tags:
    - cis_1.1.2.1.1

- name: Ensure /tmp mount directory exists
  file:
    path: /tmp
    state: directory
    mode: '1777'

- name: Add /tmp entry to /etc/fstab
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.1

- name: Ensure /tmp is mounted with nodev option
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.2

- name: Ensure /tmp is mounted with nosuid option
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.3

- name: Ensure /tmp is mounted with nodev, nosuid, and noexec
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.4

- name: Ensure /dev/shm is mounted as a separate tmpfs partition with secure options
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.2.1

- name: Ensure nodev is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.2

- name: Ensure nosuid is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.3

- name: Ensure noexec is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.4

# - name: Mount /home on its own partition
#   mount:
#     path: /home
#     src: "/dev/vg_main/lv_home"
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.1

# - name: Ensure /home is mounted with nodev
#   mount:
#     path: /home
#     src: /dev/vg_main/lv_home
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.2

# - name: Ensure /home is mounted with nosuid
#   mount:
#     path: /home
#     src: /dev/vg_main/lv_home
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.3

# - name: Mount /var as a separate partition
#   mount:
#     path: /var
#     src: /dev/xvdf1
#     fstype: ext4
#     opts: defaults,nosuid,nodev,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 2

# - name: Ensure nodev option is set on /var
#   mount:
#     path: /var
#     src: /dev/xvdf1
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 2

# - name: Ensure mount point exists for /var/tmp
#   file:
#     path: /var/tmp
#     state: directory
#     mode: '1777'

# - name: Mount /var/tmp with secure options
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1           # Replace with your actual device
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 0

# - name: Persist mount in /etc/fstab
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1           # Replace with your actual device
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: present
#     dump: 0
#     passno: 0

# - name: Ensure /var/tmp is mounted with nodev option
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1               # ðŸ” Replace with the correct device
#     fstype: ext4                  # ðŸ” Adjust if you're using a different filesystem
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 0

# - name: Ensure /var/tmp fstab entry is present with nodev option
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1               # ðŸ” Replace as needed
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: present
#     dump: 0
#     passno: 0

# - name: Remount /var/tmp with noexec option if already mounted
#   mount:
#     path: /var/tmp
#     fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='fstype') | first | default('ext4') }}"
#     opts: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='options') | first | default([]) 
#              | union(['noexec']) 
#              | union(['nodev']) 
#              | union(['nosuid']) 
#              | unique | join(',') }}"
#     state: remounted

# - name: Ensure /var/tmp entry in /etc/fstab has noexec, nodev, nosuid
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^([^#\s]+\s+/var/tmp\s+[^#\s]+\s+)([^#\s]+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is on a separate partition
#   command: findmnt -n /var/log
#   register: varlog_mount
#   changed_when: false
#   failed_when: varlog_mount.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Please configure it manually and re-run."
#   when: varlog_mount.rc != 0

# - name: Extract filesystem type for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"

# - name: Extract existing mount options for /var/log
#   set_fact:
#     varlog_options: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure /var/log is remounted with secure mount options
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_options | union(['noexec', 'nodev', 'nosuid']) | unique | join(',') }}"
#     state: remounted

# - name: Ensure /etc/fstab entry for /var/log has secure options
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^([^#\s]+\s+/var/log\s+[^#\s]+\s+)([^#\s]+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition
#   changed_when: false
#   failed_when: varlog_partition.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention is required to create one."
#   when: varlog_partition.rc != 0

# - name: Get current fstype and mount options for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_opts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure nodev is added to mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_opts | union(['nodev']) | unique | join(',') }}"
#     state: remounted

# - name: Persist nodev in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition_check
#   changed_when: false
#   failed_when: varlog_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention required to create one as per CIS."
#   when: varlog_partition_check.rc != 0

# - name: Get current mount options and fstype for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure nosuid is added to /var/log mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_mountopts | union(['nosuid']) | union(['nodev', 'noexec', 'relatime']) | unique | join(',') }}"
#     state: remounted

# - name: Persist nosuid in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition_check
#   changed_when: false
#   failed_when: varlog_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention required to comply with CIS 1.1.2.6.4"
#   when: varlog_partition_check.rc != 0

# - name: Get current mount options and fstype for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure noexec is added to /var/log mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_mountopts | union(['noexec']) | union(['nosuid', 'nodev', 'relatime']) | unique | join(',') }}"
#     state: remounted

# - name: Persist noexec in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log/audit is not a separate partition
#   fail:
#     msg: "/var/log/audit is not a separate partition. Please create a dedicated partition as per CIS 1.1.2.7.1"
#   when: audit_partition_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if nodev option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w nodev
#   register: nodev_option_check
#   changed_when: false
#   failed_when: nodev_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if nodev is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'nodev' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.2."
#   when: audit_partition_check.rc == 0 and nodev_option_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if nosuid option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w nosuid
#   register: nosuid_option_check
#   changed_when: false
#   failed_when: nosuid_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if nosuid is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'nosuid' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.3."
#   when: audit_partition_check.rc == 0 and nosuid_option_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if noexec option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w noexec
#   register: noexec_option_check
#   changed_when: false
#   failed_when: noexec_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if noexec is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'noexec' is not set. Please update /etc/fstab and remount to comply with CIS 1.1.2.7.4."
#   when: audit_partition_check.rc == 0 and noexec_option_check.rc != 0

- name: Check for GPG key URL configuration in repos
  shell: grep -r gpgkey /etc/yum.repos.d/* /etc/dnf/dnf.conf || true
  register: gpgkey_urls
  changed_when: false

- name: Print configured GPG key URLs
  debug:
    msg: "{{ gpgkey_urls.stdout_lines }}"

- name: List installed GPG keys from rpm
  shell: |
    for RPM_PACKAGE in $(rpm -q gpg-pubkey); do
      echo "RPM: ${RPM_PACKAGE}"
      echo "Packager: $(rpm -q --queryformat '%{PACKAGER}' ${RPM_PACKAGE})"
      echo "Summary: $(rpm -q --queryformat '%{SUMMARY}' ${RPM_PACKAGE})"
      echo "Key ID: $(rpm -q --queryformat '%{VERSION}' ${RPM_PACKAGE})"
      echo "Created: $(date -d "1970-01-01 +$((0x$(rpm -q --queryformat '%{RELEASE}' ${RPM_PACKAGE})) ) sec" +%Y-%m-%d)"
      echo ""
    done
  register: installed_gpg_keys
  changed_when: false

- name: Display installed GPG keys
  debug:
    msg: "{{ installed_gpg_keys.stdout_lines }}"

- name: Ensure gpgcheck is set to 1 in /etc/dnf/dnf.conf
  ansible.builtin.lineinfile:
    path: /etc/dnf/dnf.conf
    regexp: '^gpgcheck\s*='
    line: 'gpgcheck=1'
    insertafter: '^\[main\]'
    backup: yes
  #notify: Reload DNF

- name: Ensure gpgcheck is set to 1 in all yum repo files
  ansible.builtin.find:
    paths: /etc/yum.repos.d/
    patterns: "*.repo"
  register: repo_files

- name: Fix gpgcheck entries in all repo files
  ansible.builtin.replace:
    path: "{{ item.path }}"
    regexp: '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)\b'
    replace: 'gpgcheck=1'
    backup: yes
  loop: "{{ repo_files.files }}"
  when: repo_files.matched > 0
  #notify: Reload DNF

- name: Audit gpgcheck in dnf.conf
  command: grep '^gpgcheck=' /etc/dnf/dnf.conf
  register: dnf_gpgcheck
  changed_when: false

- name: Ensure gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files

- name: Set gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*gpgcheck\s*=\s*'
    line: 'gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files.files }}"
  when: yum_repo_files.matched > 0

- name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: repo_gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure repo_gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files_for_repo_gpgcheck

- name: Set repo_gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*repo_gpgcheck\s*=\s*'
    line: 'repo_gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
  when: yum_repo_files_for_repo_gpgcheck.matched > 0

- name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: repo_gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure repo_gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files_for_repo_gpgcheck

- name: Set repo_gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*repo_gpgcheck\s*=\s*'
    line: 'repo_gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
  when: yum_repo_files_for_repo_gpgcheck.matched > 0

- name: "CIS 1.2.4 | Audit: Ensure package manager repositories are configured"
  ansible.builtin.shell: "dnf repolist --quiet | grep -E '^[a-zA-Z0-9_-]+\\s+.+\\s+[0-9]+'"
  register: repo_check
  changed_when: false
  failed_when: repo_check.stdout_lines | length == 0
  tags:
    - level1
    - section1.2.4

- name: "CIS 1.2.5 | Audit: Check for available package updates"
  ansible.builtin.shell: "dnf check-update || true"
  register: dnf_check
  changed_when: false
  failed_when: false
  tags:
    - level1
    - section1.2.5

- name: CIS 1.2.5 | Ensure updates, patches, and additional security software are installed
  shell: |
    dnf update -y && dnf needs-restarting -r || true
  register: cis_125_updates
  changed_when: cis_125_updates.rc != 0 or ('Nothing to do' not in cis_125_updates.stdout | default(''))
  failed_when: false
  tags:
    - level1-server
    - level1-workstation
    - patching

- name: "CIS 1.4.1 | Ensure ASLR is enabled (kernel.randomize_va_space = 2)"
  ansible.posix.sysctl:
    name: kernel.randomize_va_space
    value: '2'
    sysctl_set: true
    state: present
    reload: yes
  tags:
    - level1-server
    - level1-workstation
    - sysctl
    - aslr

- name: "CIS 1.4.2 | Ensure ptrace_scope is restricted (kernel.yama.ptrace_scope = 1)"
  ansible.posix.sysctl:
    name: kernel.yama.ptrace_scope
    value: "1"
    sysctl_set: true
    state: present
    reload: yes
  tags:
    - level1-server
    - level1-workstation
    - ptrace
    - sysctl

- name: "CIS 1.4.3 | Ensure core dump backtraces are disabled (ProcessSizeMax=0)"
  ansible.builtin.lineinfile:
    path: /etc/systemd/coredump.conf
    regexp: '^#?ProcessSizeMax='
    line: 'ProcessSizeMax=0'
    create: yes
    backup: yes
  #notify: Reload systemd-coredump
  tags:
    - level1-server
    - level1-workstation
    - coredump

- name: "CIS 1.4.4 | Ensure core dump storage is disabled (Storage=none)"
  ansible.builtin.lineinfile:
    path: /etc/systemd/coredump.conf
    regexp: '^#?Storage='
    line: 'Storage=none'
    create: yes
    backup: yes
  #notify: Reload systemd-coredump

- name: CIS 1.5.1.1 | Ensure SELinux is installed using bash fallback
  ansible.builtin.shell: |
    if ! rpm -q libselinux >/dev/null 2>&1; then
      dnf install -y libselinux --nogpgcheck
    fi
  register: selinux_install_result
  changed_when: selinux_install_result.rc == 0
  failed_when: selinux_install_result.rc != 0



