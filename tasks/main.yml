- name: "1.1.1.1 | Ensure cramfs kernel module is not available (Automated)"
  block:

    - name: Check if cramfs kernel module is available
      command: modinfo cramfs
      register: cramfs_module
      ignore_errors: true
      changed_when: false

    - name: Unload cramfs kernel module if loaded
      ansible.builtin.shell: "modprobe -r cramfs"
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"
      ignore_errors: true

    - name: Blacklist cramfs module
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/cramfs.conf
        line: "blacklist cramfs"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"

    - name: Prevent cramfs module from loading
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/cramfs.conf
        line: "install cramfs /bin/false"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'cramfs_module' in vars and cramfs_module.rc == 0"

  rescue:
    - name: Fallback info if cramfs_module was not defined
      debug:
        msg: "cramfs module not available or 'modinfo' command failed — skipping tasks"

- name: "1.1.1.2 | Ensure freevxfs kernel module is not available (Automated)"
  block:

    - name: Check if freevxfs kernel module is available
      command: modinfo freevxfs
      register: freevxfs_module
      ignore_errors: true
      changed_when: false

    - name: Unload freevxfs kernel module if loaded
      ansible.builtin.shell: "modprobe -r freevxfs"
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"
      ignore_errors: true

    - name: Blacklist freevxfs module
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/freevxfs.conf
        line: "blacklist freevxfs"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

    - name: Prevent freevxfs module from loading
      ansible.builtin.lineinfile:
        path: /etc/modprobe.d/freevxfs.conf
        line: "install freevxfs /bin/false"
        create: yes
        mode: '0644'
        owner: root
        group: root
      when: "'freevxfs_module' in vars and freevxfs_module.rc == 0"

  rescue:
    - name: Fallback info if freevxfs_module was not defined
      debug:
        msg: "freevxfs module not available or 'modinfo' command failed — skipping tasks"

# 1.1.1.3 Ensure hfs kernel module is not available
- name: Check if hfs kernel module is available
  command: modinfo hfs
  register: hfs_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3



- name: Unload hfs kernel module if loaded
  command: modprobe -r hfs
  when: hfs_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

- name: Blacklist hfs module
  lineinfile:
    path: /etc/modprobe.d/hfs.conf
    line: "blacklist hfs"
    create: yes
  when: hfs_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

- name: Prevent hfs module from loading
  lineinfile:
    path: /etc/modprobe.d/hfs.conf
    line: "install hfs /bin/false"
    create: yes
  when: hfs_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.3

# 1.1.1.4 Ensure hfsplus kernel module is not available
- name: Check if hfsplus kernel module is available
  command: modinfo hfsplus
  register: hfsplus_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Unload hfsplus kernel module if loaded
  command: modprobe -r hfsplus
  when: hfsplus_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Blacklist hfsplus module
  lineinfile:
    path: /etc/modprobe.d/hfsplus.conf
    line: "blacklist hfsplus"
    create: yes
  when: hfsplus_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

- name: Prevent hfsplus module from loading
  lineinfile:
    path: /etc/modprobe.d/hfsplus.conf
    line: "install hfsplus /bin/false"
    create: yes
  when: hfsplus_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.4

# 1.1.1.5 Ensure jffs2 kernel module is not available
- name: Check if jffs2 kernel module is available
  command: modinfo jffs2
  register: jffs2_module
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Unload jffs2 kernel module if loaded
  command: modprobe -r jffs2
  when: jffs2_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Blacklist jffs2 module
  lineinfile:
    path: /etc/modprobe.d/jffs2.conf
    line: "blacklist jffs2"
    create: yes
  when: jffs2_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

- name: Prevent jffs2 module from loading
  lineinfile:
    path: /etc/modprobe.d/jffs2.conf
    line: "install jffs2 /bin/false"
    create: yes
  when: jffs2_module.rc == 0
  tags:
    - level1
    - server
    - workstation
    - cis_1.1.1.5

# 1.1.1.6 Ensure squashfs kernel module is not available
- name: Check if squashfs kernel module is available
  command: modinfo squashfs
  register: squashfs_module
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Unload squashfs kernel module if loaded
  command: modprobe -r squashfs
  when: squashfs_module.rc == 0
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Blacklist squashfs module
  lineinfile:
    path: /etc/modprobe.d/squashfs.conf
    line: "blacklist squashfs"
    create: yes
  when: squashfs_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

- name: Prevent squashfs module from loading
  lineinfile:
    path: /etc/modprobe.d/squashfs.conf
    line: "install squashfs /bin/false"
    create: yes
  when: squashfs_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.6

# 1.1.1.7 Ensure udf kernel module is not available
- name: Check if udf kernel module is available
  command: modinfo udf
  register: udf_module
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Unload udf kernel module if loaded
  command: modprobe -r udf
  when: udf_module.rc == 0
  ignore_errors: true
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Blacklist udf module
  lineinfile:
    path: /etc/modprobe.d/udf.conf
    line: "blacklist udf"
    create: yes
  when: udf_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

- name: Prevent udf module from loading
  lineinfile:
    path: /etc/modprobe.d/udf.conf
    line: "install udf /bin/false"
    create: yes
  when: udf_module.rc == 0
  tags:
    - level2
    - server
    - workstation
    - cis_1.1.1.7

# 1.1.1.8 Ensure usb-storage kernel module is not available
- name: Check if usb-storage kernel module is available
  command: modinfo usb-storage
  register: usb_storage_module
  ignore_errors: true
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Unload usb-storage kernel module if loaded
  command: modprobe -r usb-storage
  when: usb_storage_module.rc == 0
  ignore_errors: true
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Blacklist usb-storage kernel module
  lineinfile:
    path: /etc/modprobe.d/usb-storage.conf
    line: "blacklist usb-storage"
    create: yes
  when: usb_storage_module.rc == 0
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

- name: Prevent usb-storage kernel module from loading
  lineinfile:
    path: /etc/modprobe.d/usb-storage.conf
    line: "install usb-storage /bin/false"
    create: yes
  when: usb_storage_module.rc == 0
  tags:
    - level1
    - level2
    - server
    - workstation
    - cis_1.1.1.8

# 1.1.2.1.1 Ensure /tmp is a separate partition using tmpfs
- name: Ensure systemd tmp.mount is unmasked
  command: systemctl unmask tmp.mount
  ignore_errors: true
  tags:
    - cis_1.1.2.1.1

- name: Ensure /tmp mount directory exists
  file:
    path: /tmp
    state: directory
    mode: '1777'

- name: Add /tmp entry to /etc/fstab
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.1

- name: Ensure /tmp is mounted with nodev option
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.2

- name: Ensure /tmp is mounted with nosuid option
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.3

- name: Ensure /tmp is mounted with nodev, nosuid, and noexec
  mount:
    path: /tmp
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.1.4

- name: Ensure /dev/shm is mounted as a separate tmpfs partition with secure options
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime,size=2G
    state: mounted
  tags:
    - cis_1.1.2.2.1

- name: Ensure nodev is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.2

- name: Ensure nosuid is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.3

- name: Ensure noexec is set on /dev/shm
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: defaults,rw,nosuid,nodev,noexec,relatime
    state: mounted
  tags:
    - cis_1.1.2.2.4

# - name: Mount /home on its own partition
#   mount:
#     path: /home
#     src: "/dev/vg_main/lv_home"
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.1

# - name: Ensure /home is mounted with nodev
#   mount:
#     path: /home
#     src: /dev/vg_main/lv_home
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.2

# - name: Ensure /home is mounted with nosuid
#   mount:
#     path: /home
#     src: /dev/vg_main/lv_home
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#   tags:
#     - cis_1.1.2.3.3

# - name: Mount /var as a separate partition
#   mount:
#     path: /var
#     src: /dev/xvdf1
#     fstype: ext4
#     opts: defaults,nosuid,nodev,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 2

# - name: Ensure nodev option is set on /var
#   mount:
#     path: /var
#     src: /dev/xvdf1
#     fstype: ext4
#     opts: defaults,rw,nosuid,nodev,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 2

# - name: Ensure mount point exists for /var/tmp
#   file:
#     path: /var/tmp
#     state: directory
#     mode: '1777'

# - name: Mount /var/tmp with secure options
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1           # Replace with your actual device
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 0

# - name: Persist mount in /etc/fstab
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1           # Replace with your actual device
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: present
#     dump: 0
#     passno: 0

# - name: Ensure /var/tmp is mounted with nodev option
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1               # 🔁 Replace with the correct device
#     fstype: ext4                  # 🔁 Adjust if you're using a different filesystem
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: mounted
#     dump: 0
#     passno: 0

# - name: Ensure /var/tmp fstab entry is present with nodev option
#   mount:
#     path: /var/tmp
#     src: /dev/xvdf1               # 🔁 Replace as needed
#     fstype: ext4
#     opts: defaults,nodev,nosuid,noexec,relatime
#     state: present
#     dump: 0
#     passno: 0

# - name: Remount /var/tmp with noexec option if already mounted
#   mount:
#     path: /var/tmp
#     fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='fstype') | first | default('ext4') }}"
#     opts: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/tmp') | map(attribute='options') | first | default([]) 
#              | union(['noexec']) 
#              | union(['nodev']) 
#              | union(['nosuid']) 
#              | unique | join(',') }}"
#     state: remounted

# - name: Ensure /var/tmp entry in /etc/fstab has noexec, nodev, nosuid
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^([^#\s]+\s+/var/tmp\s+[^#\s]+\s+)([^#\s]+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is on a separate partition
#   command: findmnt -n /var/log
#   register: varlog_mount
#   changed_when: false
#   failed_when: varlog_mount.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Please configure it manually and re-run."
#   when: varlog_mount.rc != 0

# - name: Extract filesystem type for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"

# - name: Extract existing mount options for /var/log
#   set_fact:
#     varlog_options: "{{ ansible_facts.mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure /var/log is remounted with secure mount options
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_options | union(['noexec', 'nodev', 'nosuid']) | unique | join(',') }}"
#     state: remounted

# - name: Ensure /etc/fstab entry for /var/log has secure options
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^([^#\s]+\s+/var/log\s+[^#\s]+\s+)([^#\s]+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition
#   changed_when: false
#   failed_when: varlog_partition.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention is required to create one."
#   when: varlog_partition.rc != 0

# - name: Get current fstype and mount options for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_opts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure nodev is added to mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_opts | union(['nodev']) | unique | join(',') }}"
#     state: remounted

# - name: Persist nodev in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,nodev,nosuid,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition_check
#   changed_when: false
#   failed_when: varlog_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention required to create one as per CIS."
#   when: varlog_partition_check.rc != 0

# - name: Get current mount options and fstype for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure nosuid is added to /var/log mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_mountopts | union(['nosuid']) | union(['nodev', 'noexec', 'relatime']) | unique | join(',') }}"
#     state: remounted

# - name: Persist nosuid in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log is a separate partition
#   command: findmnt -n /var/log
#   register: varlog_partition_check
#   changed_when: false
#   failed_when: varlog_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log is not a separate partition
#   fail:
#     msg: "/var/log is not a separate partition. Manual intervention required to comply with CIS 1.1.2.6.4"
#   when: varlog_partition_check.rc != 0

# - name: Get current mount options and fstype for /var/log
#   set_fact:
#     varlog_fstype: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='fstype') | first | default('ext4') }}"
#     varlog_mountopts: "{{ ansible_mounts | selectattr('mount', 'equalto', '/var/log') | map(attribute='options') | first | default([]) }}"

# - name: Ensure noexec is added to /var/log mount options at runtime
#   mount:
#     path: /var/log
#     fstype: "{{ varlog_fstype }}"
#     opts: "{{ varlog_mountopts | union(['noexec']) | union(['nosuid', 'nodev', 'relatime']) | unique | join(',') }}"
#     state: remounted

# - name: Persist noexec in /etc/fstab for /var/log
#   lineinfile:
#     path: /etc/fstab
#     regexp: '^(\S+\s+/var/log\s+\S+\s+)(\S+)'
#     line: '\1defaults,rw,nosuid,nodev,noexec,relatime'
#     backrefs: yes

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Fail if /var/log/audit is not a separate partition
#   fail:
#     msg: "/var/log/audit is not a separate partition. Please create a dedicated partition as per CIS 1.1.2.7.1"
#   when: audit_partition_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if nodev option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w nodev
#   register: nodev_option_check
#   changed_when: false
#   failed_when: nodev_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if nodev is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'nodev' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.2."
#   when: audit_partition_check.rc == 0 and nodev_option_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if nosuid option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w nosuid
#   register: nosuid_option_check
#   changed_when: false
#   failed_when: nosuid_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if nosuid is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'nosuid' is not set. Please update /etc/fstab and remount as per CIS 1.1.2.7.3."
#   when: audit_partition_check.rc == 0 and nosuid_option_check.rc != 0

# - name: Check if /var/log/audit is a separate partition
#   command: findmnt -n /var/log/audit
#   register: audit_partition_check
#   changed_when: false
#   failed_when: audit_partition_check.rc != 0
#   ignore_errors: true

# - name: Check if noexec option is set on /var/log/audit
#   command: findmnt -nk /var/log/audit | grep -w noexec
#   register: noexec_option_check
#   changed_when: false
#   failed_when: noexec_option_check.rc != 0
#   when: audit_partition_check.rc == 0
#   ignore_errors: true

# - name: Warn if noexec is not set on /var/log/audit
#   debug:
#     msg: "The /var/log/audit partition exists but 'noexec' is not set. Please update /etc/fstab and remount to comply with CIS 1.1.2.7.4."
#   when: audit_partition_check.rc == 0 and noexec_option_check.rc != 0

- name: Check for GPG key URL configuration in repos
  shell: grep -r gpgkey /etc/yum.repos.d/* /etc/dnf/dnf.conf || true
  register: gpgkey_urls
  changed_when: false

- name: Print configured GPG key URLs
  debug:
    msg: "{{ gpgkey_urls.stdout_lines }}"

- name: List installed GPG keys from rpm
  shell: |
    for RPM_PACKAGE in $(rpm -q gpg-pubkey); do
      echo "RPM: ${RPM_PACKAGE}"
      echo "Packager: $(rpm -q --queryformat '%{PACKAGER}' ${RPM_PACKAGE})"
      echo "Summary: $(rpm -q --queryformat '%{SUMMARY}' ${RPM_PACKAGE})"
      echo "Key ID: $(rpm -q --queryformat '%{VERSION}' ${RPM_PACKAGE})"
      echo "Created: $(date -d "1970-01-01 +$((0x$(rpm -q --queryformat '%{RELEASE}' ${RPM_PACKAGE})) ) sec" +%Y-%m-%d)"
      echo ""
    done
  register: installed_gpg_keys
  changed_when: false

- name: Display installed GPG keys
  debug:
    msg: "{{ installed_gpg_keys.stdout_lines }}"

- name: Ensure gpgcheck is set to 1 in /etc/dnf/dnf.conf
  ansible.builtin.lineinfile:
    path: /etc/dnf/dnf.conf
    regexp: '^gpgcheck\s*='
    line: 'gpgcheck=1'
    insertafter: '^\[main\]'
    backup: yes
  #notify: Reload DNF

- name: Ensure gpgcheck is set to 1 in all yum repo files
  ansible.builtin.find:
    paths: /etc/yum.repos.d/
    patterns: "*.repo"
  register: repo_files

- name: Fix gpgcheck entries in all repo files
  ansible.builtin.replace:
    path: "{{ item.path }}"
    regexp: '^\s*gpgcheck\s*=\s*(0|[2-9]|[1-9][0-9]+|[a-zA-Z_]+)\b'
    replace: 'gpgcheck=1'
    backup: yes
  loop: "{{ repo_files.files }}"
  when: repo_files.matched > 0
  #notify: Reload DNF

- name: Audit gpgcheck in dnf.conf
  command: grep '^gpgcheck=' /etc/dnf/dnf.conf
  register: dnf_gpgcheck
  changed_when: false

- name: Ensure gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files

- name: Set gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*gpgcheck\s*=\s*'
    line: 'gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files.files }}"
  when: yum_repo_files.matched > 0

- name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: repo_gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure repo_gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files_for_repo_gpgcheck

- name: Set repo_gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*repo_gpgcheck\s*=\s*'
    line: 'repo_gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
  when: yum_repo_files_for_repo_gpgcheck.matched > 0

- name: Ensure repo_gpgcheck is set to 1 in global dnf.conf
  ini_file:
    path: /etc/dnf/dnf.conf
    section: main
    option: repo_gpgcheck
    value: '1'
    state: present
    backup: yes

- name: Ensure repo_gpgcheck is set to 1 in all yum repo files
  find:
    paths: /etc/yum.repos.d/
    patterns: '*.repo'
  register: yum_repo_files_for_repo_gpgcheck

- name: Set repo_gpgcheck=1 in each repo file
  lineinfile:
    path: "{{ item.path }}"
    regexp: '^\s*repo_gpgcheck\s*=\s*'
    line: 'repo_gpgcheck=1'
    state: present
    backup: yes
  loop: "{{ yum_repo_files_for_repo_gpgcheck.files }}"
  when: yum_repo_files_for_repo_gpgcheck.matched > 0

- name: "CIS 1.2.4 | Audit: Ensure package manager repositories are configured"
  ansible.builtin.shell: "dnf repolist --quiet | grep -E '^[a-zA-Z0-9_-]+\\s+.+\\s+[0-9]+'"
  register: repo_check
  changed_when: false
  failed_when: repo_check.stdout_lines | length == 0
  tags:
    - level1
    - section1.2.4

- name: "CIS 1.2.5 | Audit: Check for available package updates"
  ansible.builtin.shell: "dnf check-update || true"
  register: dnf_check
  changed_when: false
  failed_when: false
  tags:
    - level1
    - section1.2.5

- name: CIS 1.2.5 | Ensure updates, patches, and additional security software are installed
  shell: |
    dnf update -y && dnf needs-restarting -r || true
  register: cis_125_updates
  changed_when: cis_125_updates.rc != 0 or ('Nothing to do' not in cis_125_updates.stdout | default(''))
  failed_when: false
  tags:
    - level1-server
    - level1-workstation
    - patching

- name: "CIS 1.4.1 | Ensure ASLR is enabled (kernel.randomize_va_space = 2)"
  ansible.posix.sysctl:
    name: kernel.randomize_va_space
    value: '2'
    sysctl_set: true
    state: present
    reload: yes
  tags:
    - level1-server
    - level1-workstation
    - sysctl
    - aslr

- name: "CIS 1.4.2 | Ensure ptrace_scope is restricted (kernel.yama.ptrace_scope = 1)"
  ansible.posix.sysctl:
    name: kernel.yama.ptrace_scope
    value: "1"
    sysctl_set: true
    state: present
    reload: yes
  tags:
    - level1-server
    - level1-workstation
    - ptrace
    - sysctl

- name: "CIS 1.4.3 | Ensure core dump backtraces are disabled (ProcessSizeMax=0)"
  ansible.builtin.lineinfile:
    path: /etc/systemd/coredump.conf
    regexp: '^#?ProcessSizeMax='
    line: 'ProcessSizeMax=0'
    create: yes
    backup: yes
  #notify: Reload systemd-coredump
  tags:
    - level1-server
    - level1-workstation
    - coredump

- name: "CIS 1.4.4 | Ensure core dump storage is disabled (Storage=none)"
  ansible.builtin.lineinfile:
    path: /etc/systemd/coredump.conf
    regexp: '^#?Storage='
    line: 'Storage=none'
    create: yes
    backup: yes
  #notify: Reload systemd-coredump

- name: CIS 1.5.1.1 | Ensure SELinux is installed using bash fallback
  ansible.builtin.shell: |
    if ! rpm -q libselinux >/dev/null 2>&1; then
      dnf install -y libselinux --nogpgcheck
    fi
  register: selinux_install_result
  changed_when: selinux_install_result.rc == 0
  failed_when: selinux_install_result.rc != 0

- name: CIS 1.5.1.2 | Ensure SELinux is not disabled in bootloader configuration
  ansible.builtin.command: grubby --update-kernel ALL --remove-args "selinux=0 enforcing=0"
  register: selinux_boot_fix
  changed_when: selinux_boot_fix.rc == 0
  failed_when: selinux_boot_fix.rc != 0

- name: CIS 1.5.1.3 | Ensure SELINUXTYPE is configured as targeted or mls
  ansible.builtin.lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUXTYPE='
    line: 'SELINUXTYPE=targeted'
    state: present
    backup: yes

- name: CIS 1.5.1.4 | Ensure SELinux mode is not disabled in config file
  ansible.builtin.lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: 'SELINUX=enforcing'
    backup: yes

- name: CIS 1.5.1.4 | Set SELinux running mode to enforcing
  ansible.builtin.command: setenforce 1
  when: ansible_selinux.status == "permissive"
  changed_when: true
  failed_when: false

- name: CIS 1.5.1.5 | Ensure SELinux mode is set to enforcing in config file
  ansible.builtin.lineinfile:
    path: /etc/selinux/config
    regexp: '^SELINUX='
    line: 'SELINUX=enforcing'
    backup: yes

- name: CIS 1.5.1.5 | Ensure SELinux runtime mode is enforcing
  ansible.builtin.command: setenforce 1
  when: ansible_selinux.status != "enforcing"
  changed_when: true
  failed_when: false

- name: CIS 1.5.1.6 | Audit for unconfined services
  ansible.builtin.command: ps -eZ
  register: unconfined_processes

- name: CIS 1.5.1.6 | Fail if unconfined services are found
  ansible.builtin.fail:
    msg: "Unconfined services exist: {{ unconfined_list }}"
  when: unconfined_list | length > 0
  vars:
    unconfined_list: "{{ unconfined_processes.stdout_lines | select('search', 'unconfined_service_t') | list }}"

- name: CIS 1.5.1.7 | Check if mcstrans is installed
  ansible.builtin.package_facts:

- name: CIS 1.5.1.7 | Remove mcstrans package if installed
  ansible.builtin.package:
    name: mcstrans
    state: absent
  when: "'mcstrans' in ansible_facts.packages"

- name: CIS 1.5.1.8 | Check if setroubleshoot is installed
  ansible.builtin.package_facts:

- name: CIS 1.5.1.8 | Remove setroubleshoot if installed
  ansible.builtin.package:
    name: setroubleshoot
    state: absent
  when: "'setroubleshoot' in ansible_facts.packages"

- name: CIS 1.6.1 | Check if system-wide crypto policy is LEGACY
  ansible.builtin.command: grep -Pi '^\h*LEGACY\b' /etc/crypto-policies/config
  register: legacy_crypto_policy_check
  changed_when: false
  failed_when: false

- name: CIS 1.6.1 | Remediate if system-wide crypto policy is LEGACY
  ansible.builtin.command: update-crypto-policies --set DEFAULT
  when: legacy_crypto_policy_check.rc == 0

- name: CIS 1.6.1 | Ensure crypto policy changes are applied
  ansible.builtin.command: update-crypto-policies
  when: legacy_crypto_policy_check.rc == 0

- name: CIS 1.6.2 | Create NO-SHA1 policy module to disable SHA1
  ansible.builtin.copy:
    dest: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
    content: |
      # This is a subpolicy dropping the SHA1 hash and signature support
      hash = -SHA1
      sign = -*-SHA1
      sha1_in_certs = 0
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.6.2 | Apply crypto policy with NO-SHA1 module
  ansible.builtin.command: update-crypto-policies --set DEFAULT:NO-SHA1
  register: crypto_policy_sha1
  changed_when: "'DEFAULT:NO-SHA1' not in crypto_policy_sha1.stdout"

- name: CIS 1.6.2 | Reboot system to activate crypto policy (manual or controlled)
  ansible.builtin.debug:
    msg: "System needs to be rebooted to fully apply updated crypto policy."
  when: crypto_policy_sha1 is changed

- name: CIS 1.6.2 | Create NO-SHA1 subpolicy module
  copy:
    dest: /etc/crypto-policies/policies/modules/NO-SHA1.pmod
    content: |
      # This is a subpolicy dropping the SHA1 hash and signature support
      hash = -SHA1
      sign = -*-SHA1
      sha1_in_certs = 0
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.6.3 | Create NO-SSHCBC subpolicy module
  copy:
    dest: /etc/crypto-policies/policies/modules/NO-SSHCBC.pmod
    content: |
      # This is a subpolicy to disable all CBC mode ciphers
      # for the SSH protocol (libssh and OpenSSH)
      cipher@SSH = -*-CBC
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.6.4 | Create NO-WEAKMAC subpolicy module
  copy:
    dest: /etc/crypto-policies/policies/modules/NO-WEAKMAC.pmod
    content: |
      # This is a subpolicy to disable weak macs
      mac = -*-64
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.6.x | Apply crypto policy with all required subpolicies
  command: update-crypto-policies --set DEFAULT:NO-SHA1:NO-SSHCBC:NO-WEAKMAC
  register: apply_crypto_policy
  changed_when: "'DEFAULT:NO-SHA1:NO-SSHCBC:NO-WEAKMAC' not in apply_crypto_policy.stdout"

- name: CIS 1.6.x | Notify reboot is required to fully apply crypto policies
  debug:
    msg: "System reboot is required to fully apply updated crypto policy (NO-SHA1, NO-SSHCBC, NO-WEAKMAC)."
  when: apply_crypto_policy is changed

- name: CIS 1.7.2 | Set local login warning banner in /etc/issue
  copy:
    dest: /etc/issue
    content: |
      Authorized users only. All activity may be monitored and reported.
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.7.3 | Set remote login warning banner in /etc/issue.net
  copy:
    dest: /etc/issue.net
    content: |
      Authorized users only. All activity may be monitored and reported.
    owner: root
    group: root
    mode: '0644'

- name: CIS 1.7.4 | Ensure /etc/motd has correct permissions and ownership
  file:
    path: /etc/motd
    owner: root
    group: root
    mode: '0644'
    state: file

- name: CIS 1.7.5 | Ensure /etc/issue has correct permissions and ownership
  file:
    path: /etc/issue
    owner: root
    group: root
    mode: '0644'
    state: file

- name: CIS 1.7.6 | Ensure /etc/issue.net has correct permissions and ownership
  file:
    path: /etc/issue.net
    owner: root
    group: root
    mode: '0644'
    state: file

# - name: CIS 1.8.1 | Ensure GNOME Display Manager (GDM) is removed
#   package:
#     name: gdm
#     state: absent

- name: CIS 1.8.1 | Ensure GNOME Display Manager (GDM) is removed
  ansible.builtin.shell: dnf remove -y gdm

- name: "Check if GDM is installed"
  ansible.builtin.command: rpm -q gdm
  register: gdm_installed
  changed_when: false
  failed_when: false

- name: "CIS 1.8.2 | Ensure GDM login banner is configured"
  block:
    - name: "Ensure /etc/dconf/profile/gdm exists"
      ansible.builtin.copy:
        dest: /etc/dconf/profile/gdm
        content: |
          user-db:user
          system-db:gdm
          file-db:/usr/share/gdm/greeter-dconf-defaults
        owner: root
        group: root
        mode: '0644'

    - name: "Ensure dconf directory exists"
      ansible.builtin.file:
        path: /etc/dconf/db/gdm.d/
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: "Configure banner message"
      ansible.builtin.copy:
        dest: /etc/dconf/db/gdm.d/01-banner-message
        content: |
          [org/gnome/login-screen]
          banner-message-enable=true
          banner-message-text='Authorized users only. All activity may be monitored and reported.'
        owner: root
        group: root
        mode: '0644'

    - name: "Run dconf update"
      ansible.builtin.command: dconf update

  when: gdm_installed.rc == 0

- name: "Check if GDM is installed"
  ansible.builtin.command: rpm -q gdm
  register: gdm_installed
  changed_when: false
  failed_when: false

- name: "CIS 1.8.3 | Ensure GDM disable-user-list option is enabled"
  block:

    - name: "Ensure dconf profile exists for gdm"
      ansible.builtin.copy:
        dest: /etc/dconf/profile/gdm
        content: |
          user-db:user
          system-db:gdm
          file-db:/usr/share/gdm/greeter-dconf-defaults
        owner: root
        group: root
        mode: '0644'

    - name: "Ensure dconf db directory exists"
      ansible.builtin.file:
        path: /etc/dconf/db/gdm.d/
        state: directory
        owner: root
        group: root
        mode: '0755'

    - name: "Configure disable-user-list in gdm"
      ansible.builtin.copy:
        dest: /etc/dconf/db/gdm.d/00-login-screen
        content: |
          [org/gnome/login-screen]
          # Do not show the user list
          disable-user-list=true
        owner: root
        group: root
        mode: '0644'

    - name: "Update dconf database"
      ansible.builtin.command: dconf update

  when: gdm_installed.rc == 0

- name: "Check if GDM is installed"
  ansible.builtin.command: rpm -q gdm
  register: gdm_installed
  changed_when: false
  failed_when: false

- name: "CIS 1.8.4 | Ensure GDM screen locks when the user is idle"
  block:

    - name: "Ensure /etc/dconf/profile/gdm exists"
      ansible.builtin.copy:
        dest: /etc/dconf/profile/gdm
        content: |
          user-db:user
          system-db:gdm
          file-db:/usr/share/gdm/greeter-dconf-defaults
        owner: root
        group: root
        mode: '0644'

    - name: "Ensure /etc/dconf/db/gdm.d exists"
      ansible.builtin.file:
        path: /etc/dconf/db/gdm.d
        state: directory
        mode: '0755'
        owner: root
        group: root

    - name: "Set idle-delay and lock-delay in GDM keyfile"
      ansible.builtin.copy:
        dest: /etc/dconf/db/gdm.d/00-screensaver
        content: |
          [org/gnome/desktop/session]
          # Number of seconds of inactivity before the screen goes blank
          idle-delay=uint32 900

          [org/gnome/desktop/screensaver]
          # Number of seconds after the screen is blank before locking the screen
          lock-delay=uint32 5
        owner: root
        group: root
        mode: '0644'

    - name: "Update dconf database"
      ansible.builtin.command: dconf update

  when: gdm_installed.rc == 0

- name: "Check if GDM is installed"
  ansible.builtin.command: rpm -q gdm
  register: gdm_installed
  changed_when: false
  failed_when: false

- name: "Get dconf db directory containing idle-delay"
  ansible.builtin.shell: |
    grep -Psril '^\h*idle-delay\h*=\h*uint32\h+\d+\b' /etc/dconf/db/*/ | head -n 1
  register: idle_delay_keyfile
  changed_when: false
  failed_when: false
  when: gdm_installed.rc == 0

- name: "Extract dconf db directory"
  ansible.builtin.set_fact:
    dconf_lock_dir: "{{ idle_delay_keyfile.stdout | regex_replace('/[^/]+$', '') }}"
  when: idle_delay_keyfile is defined and (idle_delay_keyfile.stdout | default('')) != ""


- name: "Ensure locks directory exists"
  ansible.builtin.file:
    path: "{{ dconf_lock_dir }}/locks"
    state: directory
    owner: root
    group: root
    mode: '0755'
  when: dconf_lock_dir is defined

- name: "Create lock file to prevent override of idle-delay and lock-delay"
  ansible.builtin.copy:
    dest: "{{ dconf_lock_dir }}/locks/00-screensaver"
    content: |
      # Lock desktop screensaver settings
      /org/gnome/desktop/session/idle-delay
      /org/gnome/desktop/screensaver/lock-delay
    owner: root
    group: root
    mode: '0644'
  when: dconf_lock_dir is defined

- name: "Run dconf update"
  ansible.builtin.command: dconf update
  when: dconf_lock_dir is defined

- name: "CIS 1.8.6 | Check if GDM is installed"
  command: rpm -q gdm
  register: gdm_installed
  failed_when: false
  changed_when: false

- name: "CIS 1.8.6 | Ensure GDM automatic mounting of removable media is disabled"
  shell: |
    GDM_PROFILE="local"
    GDM_DB_DIR="/etc/dconf/db/${GDM_PROFILE}.d"
    GDM_PROFILE_FILE="/etc/dconf/profile/user"

    mkdir -p "${GDM_DB_DIR}"

    if [ ! -f "${GDM_PROFILE_FILE}" ]; then
      echo -e "user-db:user\nsystem-db:${GDM_PROFILE}" > "${GDM_PROFILE_FILE}"
    fi

    KEY_FILE="${GDM_DB_DIR}/00-media-automount"

    {
      echo "[org/gnome/desktop/media-handling]"
      echo "automount=false"
      echo "automount-open=false"
    } > "$KEY_FILE"

    dconf update
  when: gdm_installed.rc == 0
  args:
    executable: /bin/bash
  tags:
    - level1-server
    - level2-workstation
    - cis_1.8.6

- name: "CIS 1.8.7 | Lock GDM automount and automount-open settings"
  shell: |
    # Set dconf profile name (default is 'local', adjust if needed)
    GDM_PROFILE="local"
    DB_DIR="/etc/dconf/db/${GDM_PROFILE}.d"
    LOCKS_DIR="${DB_DIR}/locks"
    LOCK_FILE="${LOCKS_DIR}/00-media-automount"

    # Ensure locks directory exists
    mkdir -p "${LOCKS_DIR}"

    # Create or update the lock file
    grep -q "/org/gnome/desktop/media-handling/automount" "${LOCK_FILE}" 2>/dev/null || echo "/org/gnome/desktop/media-handling/automount" >> "${LOCK_FILE}"
    grep -q "/org/gnome/desktop/media-handling/automount-open" "${LOCK_FILE}" 2>/dev/null || echo "/org/gnome/desktop/media-handling/automount-open" >> "${LOCK_FILE}"

    # Update dconf database
    dconf update
  args:
    executable: /bin/bash
  when: gdm_installed.rc == 0
  tags:
    - level1-server
    - level2-workstation
    - cis_1.8.7

- name: "CIS 1.8.8 | Ensure GDM autorun-never is enabled"
  shell: |
    GP_NAME="local"
    KFILE="/etc/dconf/db/${GP_NAME}.d/00-media-autorun"
    GPDIR="/etc/dconf/db/${GP_NAME}.d"
    GPFILE="/etc/dconf/profile/user"

    # Create profile file if not present
    if ! grep -Pq "^\s*system-db:${GP_NAME}\b" $GPFILE 2>/dev/null; then
      echo -e "\nuser-db:user" >> $GPFILE
      echo "system-db:${GP_NAME}" >> $GPFILE
    fi

    # Ensure dconf directory exists
    mkdir -p "$GPDIR"

    # Create or update autorun-never entry
    if grep -Pqs '^\s*autorun-never\s*=\s*true\b' "$KFILE"; then
      echo "autorun-never already set to true"
    elif grep -Psq '^\s*autorun-never' "$KFILE"; then
      sed -ri 's/(^\s*autorun-never\s*=\s*)(\S+)(\s*.*)$/\1true\3/' "$KFILE"
    else
      grep -Psq '^\s*\[org/gnome/desktop/media-handling\]' "$KFILE" || echo '[org/gnome/desktop/media-handling]' >> "$KFILE"
      sed -ri '/^\s*\[org\/gnome\/desktop\/media-handling\]/a autorun-never=true' "$KFILE"
    fi

    # Update dconf database
    dconf update
  args:
    executable: /bin/bash
  when: gdm_installed.rc == 0
  tags:
    - level1-server
    - level1-workstation
    - cis_1.8.8

- name: "CIS 1.8.9 | Ensure GDM autorun-never is not overridden"
  shell: |
    GP_NAME="local"
    GP_DIR="/etc/dconf/db/${GP_NAME}.d"
    LOCKS_DIR="${GP_DIR}/locks"
    LOCK_FILE="${LOCKS_DIR}/00-media-autorun"

    # Identify actual directory if setting already exists
    if grep -Prilsq -- '^\s*autorun-never\s*=' /etc/dconf/db/*.d; then
      GP_NAME="$(grep -Prils -- '^\s*autorun-never\s*=' /etc/dconf/db/*.d | head -n1 | awk -F'/' '{split($(NF-1), a, "."); print a[1]}')"
      GP_DIR="/etc/dconf/db/${GP_NAME}.d"
      LOCKS_DIR="${GP_DIR}/locks"
      LOCK_FILE="${LOCKS_DIR}/00-media-autorun"
    fi

    # Create the locks directory if not exists
    mkdir -p "$LOCKS_DIR"

    # Ensure lock line exists
    grep -Fxq "/org/gnome/desktop/media-handling/autorun-never" "$LOCK_FILE" 2>/dev/null || {
      echo "# Lock desktop media-handling autorun-never setting" >> "$LOCK_FILE"
      echo "/org/gnome/desktop/media-handling/autorun-never" >> "$LOCK_FILE"
    }

    # Update dconf
    dconf update
  args:
    executable: /bin/bash
  when: gdm_installed.rc == 0
  tags:
    - level1-server
    - level1-workstation
    - cis_1.8.9

- name: "CIS 1.8.10 | Ensure XDMCP is not enabled"
  block:
    - name: "Check if GDM is installed"
      command: rpm -q gdm
      register: gdm_installed
      failed_when: false
      changed_when: false

    - name: "Ensure XDMCP Enable=true is not set in /etc/gdm/custom.conf"
      lineinfile:
        path: /etc/gdm/custom.conf
        regexp: '^\s*Enable\s*=\s*true'
        state: absent
        backup: yes
      when: gdm_installed.rc == 0
      notify: reload gdm
  tags:
    - level1-server
    - level1-workstation
    - cis_1.8.10

- name: "CIS 2.1.1 | Ensure time synchronization is in use"
  block:

    - name: "Check if chrony is installed"
      command: rpm -q chrony
      register: chrony_installed
      failed_when: false
      changed_when: false

    - name: "Install chrony if not present"
      ansible.builtin.yum:
        name: chrony
        state: present
      when: chrony_installed.rc != 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.1.1

- name: "CIS 2.1.2 | Ensure chrony is configured"
  block:

    - name: "Check if chrony.conf has server or pool entries"
      command: grep -Prs -- '^\s*(server|pool)\s+[^#\n\r]+' /etc/chrony.conf
      register: chrony_configured
      failed_when: false
      changed_when: false

    - name: "Configure chrony with remote NTP servers if missing"
      blockinfile:
        path: /etc/chrony.conf
        marker: "# {mark} ANSIBLE MANAGED BLOCK: CIS 2.1.2 NTP Configuration"
        block: |
          server time1.google.com iburst
          server time2.google.com iburst
          server time3.google.com iburst
      when: chrony_configured.rc != 0

    - name: "Ensure chronyd service is enabled and running"
      service:
        name: chronyd
        state: started
        enabled: true

  tags:
    - level1-server
    - level1-workstation
    - cis_2.1.2

- name: "CIS 2.1.3 | Ensure chrony is not run as the root user"
  block:

    - name: "Ensure chronyd OPTIONS is set to run as 'chrony' user"
      lineinfile:
        path: /etc/sysconfig/chronyd
        regexp: '^OPTIONS='
        line: 'OPTIONS="-u chrony"'
        create: yes
        backup: yes

    - name: "Reload or restart chronyd service"
      systemd:
        name: chronyd
        state: restarted
        daemon_reload: yes

  tags:
    - level1-server
    - level1-workstation
    - cis_2.1.3

- name: "CIS 2.2.1 | Ensure autofs services are not in use"
  block:

    - name: "Check if autofs is installed"
      command: rpm -q autofs
      register: autofs_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove autofs package if installed"
      yum:
        name: autofs
        state: absent
      when: autofs_installed.rc == 0

    - name: "Stop autofs service if it exists"
      systemd:
        name: autofs
        state: stopped
        enabled: false
        masked: true
      when: autofs_installed.rc == 0

  tags:
    - level1-server
    - level2-workstation
    - cis_2.2.1

- name: "CIS 2.2.2 | Ensure avahi daemon services are not in use"
  block:

    - name: "Check if avahi is installed"
      command: rpm -q avahi
      register: avahi_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove avahi package if installed"
      yum:
        name: avahi
        state: absent
      when: avahi_installed.rc == 0

    - name: "Stop and mask avahi-daemon services if avahi is present"
      block:
        - name: "Stop avahi-daemon.service and socket"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - avahi-daemon.service
            - avahi-daemon.socket

        - name: "Mask avahi-daemon.service and socket"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - avahi-daemon.service
            - avahi-daemon.socket
      when: avahi_installed.rc == 0

  tags:
    - level1-server
    - level2-workstation
    - cis_2.2.2

- name: "CIS 2.2.3 | Ensure DHCP server services are not in use"
  block:

    - name: "Check if dhcp-server is installed"
      command: rpm -q dhcp-server
      register: dhcp_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove dhcp-server package if installed"
      yum:
        name: dhcp-server
        state: absent
      when: dhcp_installed.rc == 0

    - name: "Stop and mask dhcpd and dhcpd6 services if dhcp-server is installed"
      block:
        - name: "Stop dhcpd and dhcpd6 services"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - dhcpd.service
            - dhcpd6.service

        - name: "Mask dhcpd and dhcpd6 services"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - dhcpd.service
            - dhcpd6.service
      when: dhcp_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.3

- name: "CIS 2.2.4 | Ensure DNS server services are not in use"
  block:

    - name: "Check if bind package is installed"
      command: rpm -q bind
      register: bind_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove bind package if installed"
      yum:
        name: bind
        state: absent
      when: bind_installed.rc == 0

    - name: "Stop and mask named.service if bind is installed and cannot be removed"
      block:
        - name: "Stop named.service"
          systemd:
            name: named.service
            state: stopped
            enabled: false

        - name: "Mask named.service"
          systemd:
            name: named.service
            masked: true
      when: bind_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.4

- name: "CIS 2.2.5 | Ensure dnsmasq services are not in use"
  block:

    - name: "Check if dnsmasq package is installed"
      command: rpm -q dnsmasq
      register: dnsmasq_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove dnsmasq package if installed"
      yum:
        name: dnsmasq
        state: absent
      when: dnsmasq_installed.rc == 0

    - name: "Stop and mask dnsmasq.service if package is installed and cannot be removed"
      block:
        - name: "Stop dnsmasq.service"
          systemd:
            name: dnsmasq.service
            state: stopped
            enabled: false

        - name: "Mask dnsmasq.service"
          systemd:
            name: dnsmasq.service
            masked: true
      when: dnsmasq_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.5

- name: "CIS 2.2.6 | Ensure samba file server services are not in use"
  block:

    - name: "Check if samba package is installed"
      command: rpm -q samba
      register: samba_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove samba package if installed"
      yum:
        name: samba
        state: absent
      when: samba_installed.rc == 0

    - name: "Stop and mask smb.service if samba package is installed and cannot be removed"
      block:
        - name: "Stop smb.service"
          systemd:
            name: smb.service
            state: stopped
            enabled: false

        - name: "Mask smb.service"
          systemd:
            name: smb.service
            masked: true
      when: samba_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.6

- name: "CIS 2.2.7 | Ensure ftp server services are not in use"
  block:

    - name: "Check if vsftpd package is installed"
      command: rpm -q vsftpd
      register: vsftpd_installed
      ignore_errors: yes
      changed_when: false

    - name: "Remove vsftpd package if installed"
      yum:
        name: vsftpd
        state: absent
      when: vsftpd_installed.rc == 0

    - name: "Stop and mask vsftpd.service if vsftpd package is installed and not removed"
      block:
        - name: "Stop vsftpd.service"
          systemd:
            name: vsftpd.service
            state: stopped
            enabled: false

        - name: "Mask vsftpd.service"
          systemd:
            name: vsftpd.service
            masked: true
      when: vsftpd_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.7

- name: "CIS 2.2.8 | Ensure message access server services are not in use"
  block:

    - name: "Check if dovecot package is installed"
      command: rpm -q dovecot
      register: dovecot_installed
      ignore_errors: true
      changed_when: false

    - name: "Check if cyrus-imapd package is installed"
      command: rpm -q cyrus-imapd
      register: cyrus_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove dovecot and cyrus-imapd packages if installed"
      yum:
        name:
          - dovecot
          - cyrus-imapd
        state: absent
      when: dovecot_installed.rc == 0 or cyrus_installed.rc == 0

    - name: "Stop and mask dovecot and cyrus-imapd services if packages are required"
      block:
        - name: "Stop dovecot and cyrus-imapd services"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - dovecot.socket
            - dovecot.service
            - cyrus-imapd.service
          ignore_errors: true

        - name: "Mask dovecot and cyrus-imapd services"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - dovecot.socket
            - dovecot.service
            - cyrus-imapd.service
          ignore_errors: true
      when: dovecot_installed.rc == 0 or cyrus_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.8

- name: "CIS 2.2.9 | Ensure NFS services are not in use"
  block:

    - name: "Check if nfs-utils package is installed"
      command: rpm -q nfs-utils
      register: nfs_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove nfs-utils package if installed"
      yum:
        name: nfs-utils
        state: absent
      when: nfs_installed.rc == 0

    - name: "Stop and mask nfs-server service if package is required"
      block:
        - name: "Stop nfs-server.service"
          systemd:
            name: nfs-server.service
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask nfs-server.service"
          systemd:
            name: nfs-server.service
            masked: true
          ignore_errors: true
      when: nfs_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.9

- name: "CIS 2.2.10 | Ensure NIS server services are not in use"
  block:

    - name: "Check if ypserv package is installed"
      command: rpm -q ypserv
      register: ypserv_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove ypserv package if installed"
      yum:
        name: ypserv
        state: absent
      when: ypserv_installed.rc == 0

    - name: "Stop and mask ypserv.service if package is required"
      block:
        - name: "Stop ypserv.service"
          systemd:
            name: ypserv.service
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask ypserv.service"
          systemd:
            name: ypserv.service
            masked: true
          ignore_errors: true
      when: ypserv_installed.rc == 0

  tags:
    - level1-server
    - level1-workstation
    - cis_2.2.10

- name: "CIS 2.2.11 | Ensure print server services (CUPS) are not in use"
  block:

    - name: "Check if cups package is installed"
      command: rpm -q cups
      register: cups_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove cups package if installed"
      yum:
        name: cups
        state: absent
      when: cups_installed.rc == 0

    - name: "Stop and mask cups.socket and cups.service if package is required"
      block:
        - name: "Stop cups.socket and cups.service"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - cups.socket
            - cups.service
          ignore_errors: true

        - name: "Mask cups.socket and cups.service"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - cups.socket
            - cups.service
          ignore_errors: true
      when: cups_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.11

- name: "CIS 2.2.12 | Ensure rpcbind services are not in use"
  block:

    - name: "Check if rpcbind package is installed"
      command: rpm -q rpcbind
      register: rpcbind_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove rpcbind package if installed"
      yum:
        name: rpcbind
        state: absent
      when: rpcbind_installed.rc == 0

    - name: "Stop and mask rpcbind.socket and rpcbind.service if package is required"
      block:
        - name: "Stop rpcbind.socket and rpcbind.service"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - rpcbind.socket
            - rpcbind.service
          ignore_errors: true

        - name: "Mask rpcbind.socket and rpcbind.service"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - rpcbind.socket
            - rpcbind.service
          ignore_errors: true
      when: rpcbind_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.12

- name: "CIS 2.2.13 | Ensure rsync services are not in use"
  block:

    - name: "Check if rsync-daemon package is installed"
      command: rpm -q rsync-daemon
      register: rsyncd_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove rsync-daemon package if installed"
      yum:
        name: rsync-daemon
        state: absent
      when: rsyncd_installed.rc == 0

    - name: "Stop and mask rsyncd.socket and rsyncd.service if package is required"
      block:
        - name: "Stop rsyncd.socket and rsyncd.service"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - rsyncd.socket
            - rsyncd.service
          ignore_errors: true

        - name: "Mask rsyncd.socket and rsyncd.service"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - rsyncd.socket
            - rsyncd.service
          ignore_errors: true
      when: rsyncd_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.13

- name: "CIS 2.2.14 | Ensure SNMP services are not in use"
  block:

    - name: "Check if net-snmp package is installed"
      command: rpm -q net-snmp
      register: snmp_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove net-snmp package if installed"
      yum:
        name: net-snmp
        state: absent
      when: snmp_installed.rc == 0

    - name: "Stop and mask snmpd.service if package is required"
      block:
        - name: "Stop snmpd.service"
          systemd:
            name: snmpd.service
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask snmpd.service"
          systemd:
            name: snmpd.service
            masked: true
          ignore_errors: true
      when: snmp_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.14

- name: "CIS 2.2.15 | Ensure Telnet server services are not in use"
  block:

    - name: "Check if telnet-server package is installed"
      command: rpm -q telnet-server
      register: telnet_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove telnet-server package if installed"
      yum:
        name: telnet-server
        state: absent
      when: telnet_installed.rc == 0

    - name: "Stop and mask telnet.socket if package is required"
      block:
        - name: "Stop telnet.socket"
          systemd:
            name: telnet.socket
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask telnet.socket"
          systemd:
            name: telnet.socket
            masked: true
          ignore_errors: true
      when: telnet_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.15

- name: "CIS 2.2.16 | Ensure TFTP server services are not in use"
  block:

    - name: "Check if tftp-server package is installed"
      command: rpm -q tftp-server
      register: tftp_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove tftp-server package if installed"
      yum:
        name: tftp-server
        state: absent
      when: tftp_installed.rc == 0

    - name: "Stop and mask tftp.socket and tftp.service if package is required"
      block:
        - name: "Stop tftp.socket and tftp.service"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - tftp.socket
            - tftp.service
          ignore_errors: true

        - name: "Mask tftp.socket and tftp.service"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - tftp.socket
            - tftp.service
          ignore_errors: true
      when: tftp_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.16

- name: "CIS 2.2.17 | Ensure web proxy server services (Squid) are not in use"
  block:

    - name: "Check if squid package is installed"
      command: rpm -q squid
      register: squid_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove squid package if installed"
      yum:
        name: squid
        state: absent
      when: squid_installed.rc == 0

    - name: "Stop and mask squid.service if package is required for dependency"
      block:
        - name: "Stop squid.service"
          systemd:
            name: squid.service
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask squid.service"
          systemd:
            name: squid.service
            masked: true
          ignore_errors: true
      when: squid_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.17

- name: "CIS 2.2.18 | Ensure web server services (httpd, nginx) are not in use"
  block:

    - name: "Check if httpd package is installed"
      command: rpm -q httpd
      register: httpd_installed
      ignore_errors: true
      changed_when: false

    - name: "Check if nginx package is installed"
      command: rpm -q nginx
      register: nginx_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove httpd and nginx if installed"
      yum:
        name:
          - httpd
          - nginx
        state: absent
      when: httpd_installed.rc == 0 or nginx_installed.rc == 0

    - name: "Stop and mask httpd.socket, httpd.service, and nginx.service if packages are present for dependency"
      block:
        - name: "Stop web server services"
          systemd:
            name: "{{ item }}"
            state: stopped
            enabled: false
          loop:
            - httpd.socket
            - httpd.service
            - nginx.service
          ignore_errors: true

        - name: "Mask web server services"
          systemd:
            name: "{{ item }}"
            masked: true
          loop:
            - httpd.socket
            - httpd.service
            - nginx.service
          ignore_errors: true
      when: httpd_installed.rc == 0 or nginx_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.18

- name: "CIS 2.2.19 | Ensure xinetd services are not in use"
  block:

    - name: "Check if xinetd package is installed"
      command: rpm -q xinetd
      register: xinetd_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove xinetd package if installed"
      yum:
        name: xinetd
        state: absent
      when: xinetd_installed.rc == 0

    - name: "Stop and mask xinetd.service if required as a dependency"
      block:
        - name: "Stop xinetd.service"
          systemd:
            name: xinetd.service
            state: stopped
            enabled: false
          ignore_errors: true

        - name: "Mask xinetd.service"
          systemd:
            name: xinetd.service
            masked: true
          ignore_errors: true
      when: xinetd_installed.rc == 0

  tags:
    - level1-server
    - cis_2.2.19

- name: "CIS 2.2.20 | Ensure X window server services are not in use"
  block:

    - name: "Check if xorg-x11-server-common package is installed"
      command: rpm -q xorg-x11-server-common
      register: xorg_installed
      ignore_errors: true
      changed_when: false

    - name: "Remove xorg-x11-server-common package if installed"
      yum:
        name: xorg-x11-server-common
        state: absent
      when: xorg_installed.rc == 0

  tags:
    - level2-server
    - cis_2.2.20

- name: Install postfix using yum
  shell: |
    yum install -y postfix
  args:
    warn: false

- name: Ensure Postfix is configured for local-only mode (inet_interfaces = loopback-only)
  lineinfile:
    path: /etc/postfix/main.cf
    regexp: '^inet_interfaces\s*='
    line: 'inet_interfaces = loopback-only'
    state: present
    insertafter: '^#.*RECEIVING MAIL'
    backup: yes
  notify: Restart postfix
  when: ansible_facts.packages.postfix is defined

- name: Ensure Postfix service is enabled and running
  service:
    name: postfix
    state: started
    enabled: yes
  when: ansible_facts.packages.postfix is defined

